diff --git a/.env.sample b/.env.sample
index 2b0c48590..c80c16783 100644
--- a/.env.sample
+++ b/.env.sample
@@ -31,4 +31,10 @@
 # LOCAL_FS_DB=
 
 ## Specifies the number of lines of history to be shown in the game log (default 50)
-# LOG_LENGTH=
\ No newline at end of file
+# LOG_LENGTH=
+
+## Specify the flag for the challenge
+# FLAG=<flag-goes-here>
+
+## Evict games from the in-memory cache after this many milliseconds
+# EVICT_GAMES_AFTER_MS=300000
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
index 7161d8e3b..00cd0dbbd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,7 +1,7 @@
 # Server Settings
 .env
 *.pem
-db/*
+db
 
 # Autogenerated
 .DS_Store
diff --git a/assets/index.html b/assets/index.html
index 47ca7ab6e..415424dbf 100644
--- a/assets/index.html
+++ b/assets/index.html
@@ -1,64 +1,46 @@
 <!DOCTYPE html>
 <html>
-    <head>
-        <link
-            href="https://fonts.googleapis.com/css?family=Ubuntu&display=swap"
-            rel="stylesheet"
-        />
-        <link rel="stylesheet" type="text/css" media="all" href="/styles.css" />
-        <meta name="viewport" content='width=1260, user-scalable=1' />
-        <meta name="description" content="Terraforming Mars Open Source Web Application" />
-    </head>
-    <body id="ts-preferences-target">
-        <div id="app" :class="'topmost-'+screen">
-            <section>
-                <dialog id="alert-dialog" class="alert-dialog">
-                    <form method="dialog">
-                        <p class="title" v-i18n>Error with input</p>
-                        <p id="alert-dialog-message"></p>
-                        <menu class="dialog-menu centered-content">
-                            <button id="alert-dialog-button" class="btn btn-lg btn-primary">OK</button>
-                        </menu>
-                    </form>
-                </dialog>
-            </section>
-            <div class="main-container">
-                <start-screen v-if="screen === 'start-screen'" :version="settings.version"></start-screen>
-                <create-game-form
-                    v-else-if="screen === 'create-game-form'"
-                ></create-game-form>
-                <load-game-form v-else-if="screen === 'load'"></load-game-form>
-                <game-home
-                    v-else-if="screen === 'game-home'"
-                    :game="game"
-                ></game-home>
-                <player-home
-                    v-else-if="screen === 'player-home' && playerView !== undefined"
-                    :player-view="playerView"
-                    :key="playerkey"
-                    :settings="settings"
-                ></player-home>
-                <spectator-home
-                    v-else-if="screen === 'spectator-home' && spectator !== undefined"
-                    :spectator="spectator"
-                    :key="playerkey"
-                    :settings="settings"
-                ></spectator-home>
-                <game-end
-                    v-else-if="screen === 'the-end'"
-                    :player-view="playerView"
-                    :spectator="spectator"
-                ></game-end>
-                <games-overview
-                    v-else-if="screen === 'games-overview'"
-                ></games-overview>
-                <debug-ui v-else-if="screen === 'cards'"></debug-ui>
-                <Help v-else-if="screen === 'help'"></Help>
-            </div>
-            <div class="notice">
-                Not affiliated with FryxGames, Asmodee Digital or Steam in any way.
-            </div>
+
+<head>
+    <link href="https://fonts.googleapis.com/css?family=Ubuntu&display=swap" rel="stylesheet" />
+    <link rel="stylesheet" type="text/css" media="all" href="/styles.css" />
+    <meta name="viewport" content='width=1260, user-scalable=1' />
+    <meta name="description" content="Terraforming Mars Open Source Web Application" />
+</head>
+
+<body id="ts-preferences-target">
+    <div id="app" :class="'topmost-'+screen">
+        <section>
+            <dialog id="alert-dialog" class="alert-dialog">
+                <form method="dialog">
+                    <p class="title" v-i18n>Error with input</p>
+                    <p id="alert-dialog-message"></p>
+                    <menu class="dialog-menu centered-content">
+                        <button id="alert-dialog-button" class="btn btn-lg btn-primary">OK</button>
+                    </menu>
+                </form>
+            </dialog>
+        </section>
+        <div class="main-container">
+            <start-screen v-if="screen === 'start-screen'" :version="settings.version"></start-screen>
+            <start-challenge v-if="screen === 'start-challenge'"></start-challenge>
+            <create-game-form v-else-if="screen === 'create-game-form'"></create-game-form>
+            <load-game-form v-else-if="screen === 'load'"></load-game-form>
+            <game-home v-else-if="screen === 'game-home'" :game="game"></game-home>
+            <player-home v-else-if="screen === 'player-home' && playerView !== undefined" :player-view="playerView"
+                :key="playerkey" :settings="settings"></player-home>
+            <spectator-home v-else-if="screen === 'spectator-home' && spectator !== undefined" :spectator="spectator"
+                :key="playerkey" :settings="settings"></spectator-home>
+            <game-end v-else-if="screen === 'the-end'" :player-view="playerView" :spectator="spectator"></game-end>
+            <games-overview v-else-if="screen === 'games-overview'"></games-overview>
+            <debug-ui v-else-if="screen === 'cards'"></debug-ui>
+            <Help v-else-if="screen === 'help'"></Help>
         </div>
-        <script src="/main.js"></script>
-    </body>
-</html>
+        <div class="notice">
+            Not affiliated with FryxGames, Asmodee Digital or Steam in any way.
+        </div>
+    </div>
+    <script src="/main.js"></script>
+</body>
+
+</html>
\ No newline at end of file
diff --git a/src/Challenge.ts b/src/Challenge.ts
new file mode 100644
index 000000000..6d28d5424
--- /dev/null
+++ b/src/Challenge.ts
@@ -0,0 +1,37 @@
+import {ChallengeId, GameId} from './common/Types';
+import {Database} from './database/Database';
+import {ISerializable} from './ISerializable';
+import {SerializedChallenge} from './SerializedChallenge';
+
+export class Challenge implements ISerializable<SerializedChallenge> {
+    public active: GameId | undefined;
+    public won: Array<GameId>;
+    public lost: Array<GameId>;
+
+    constructor(public id: ChallengeId) {
+      this.active = undefined;
+      this.won = [];
+      this.lost = [];
+    }
+
+    serialize(): SerializedChallenge {
+      return {
+        id: this.id,
+        active: this.active,
+        won: this.won,
+        lost: this.lost,
+      };
+    }
+
+    public static async deserialize(src: SerializedChallenge) {
+      const result = new Challenge(src.id);
+      result.active = src.active;
+      result.won.push(...src.won);
+      result.lost.push(...src.lost);
+      return result;
+    }
+
+    public save(): void {
+      Database.getInstance().saveChallenge(this.serialize());
+    }
+}
diff --git a/src/Game.ts b/src/Game.ts
index 0046fdd8f..7d2704c7d 100644
--- a/src/Game.ts
+++ b/src/Game.ts
@@ -71,6 +71,7 @@ import {IPathfindersData} from './pathfinders/IPathfindersData';
 import {ArabiaTerraBoard} from './boards/ArabiaTerraBoard';
 import {AddResourcesToCard} from './deferredActions/AddResourcesToCard';
 import {isProduction} from './utils/server';
+import {Challenge} from './Challenge';
 
 export interface Score {
   corporation: String;
@@ -221,6 +222,8 @@ export class Game implements ISerializable<SerializedGame> {
   // Syndicate Pirate Raids
   public syndicatePirateRaider: PlayerId | undefined = undefined;
 
+  public challenge: Challenge | undefined = undefined;
+
   private constructor(
     public id: GameId,
     private players: Array<Player>,
@@ -260,7 +263,8 @@ export class Game implements ISerializable<SerializedGame> {
     firstPlayer: Player,
     gameOptions: GameOptions = {...DEFAULT_GAME_OPTIONS},
     seed: number = 0,
-    spectatorId: SpectatorId | undefined = undefined): Game {
+    spectatorId: SpectatorId | undefined = undefined,
+    challenge: Challenge | undefined = undefined): Game {
     if (gameOptions.clonedGamedId !== undefined) {
       throw new Error('Cloning should not come through this execution path.');
     }
@@ -284,6 +288,7 @@ export class Game implements ISerializable<SerializedGame> {
     }
 
     const game = new Game(id, players, firstPlayer, activePlayer, gameOptions, seed, board, dealer);
+    game.challenge = challenge;
     game.spectatorId = spectatorId;
     // Initialize Ares data
     if (gameOptions.aresExtension) {
@@ -460,6 +465,7 @@ export class Game implements ISerializable<SerializedGame> {
         ];
       }),
       venusScaleLevel: this.venusScaleLevel,
+      challenge: this.challenge?.id,
     };
     if (this.aresData !== undefined) {
       result.aresData = this.aresData;
@@ -473,7 +479,7 @@ export class Game implements ISerializable<SerializedGame> {
     return result;
   }
 
-  public isSoloMode() :boolean {
+  public isSoloMode(): boolean {
     return this.players.length === 1;
   }
 
@@ -781,7 +787,7 @@ export class Game implements ISerializable<SerializedGame> {
 
     // solar Phase Option
     this.phase = Phase.SOLAR;
-    if (this.gameOptions.solarPhaseOption && ! this.marsIsTerraformed()) {
+    if (this.gameOptions.solarPhaseOption && !this.marsIsTerraformed()) {
       this.gotoWorldGovernmentTerraforming();
       return;
     }
@@ -891,7 +897,7 @@ export class Game implements ISerializable<SerializedGame> {
     });
   }
 
-  public playerIsFinishedWithDraftingPhase(initialDraft: boolean, player: Player, cards : Array<IProjectCard>): void {
+  public playerIsFinishedWithDraftingPhase(initialDraft: boolean, player: Player, cards: Array<IProjectCard>): void {
     this.draftedPlayers.add(player.id);
     this.unDraftedCards.set(player.id, cards);
 
@@ -964,7 +970,7 @@ export class Game implements ISerializable<SerializedGame> {
 
   private getNextDraft(player: Player): Player {
     let nextPlayer = this.getPlayerAfter(player);
-    if (this.generation%2 === 1) {
+    if (this.generation % 2 === 1) {
       nextPlayer = this.getPlayerBefore(player);
     }
     // Change initial draft direction on second iteration
@@ -1052,13 +1058,26 @@ export class Game implements ISerializable<SerializedGame> {
 
     Database.getInstance().saveGameResults(this.id, this.players.length, this.generation, this.gameOptions, scores);
     this.phase = Phase.END;
+
+    if (this.challenge) {
+      if (this.challenge.active !== this.id) {
+        throw new Error('BUG: The planet finished was not active');
+      }
+      this.challenge.active = undefined;
+      if (this.isSoloModeWin()) {
+        this.challenge.won.push(this.id);
+      } else {
+        this.challenge.lost.push(this.id);
+      }
+      this.challenge.save();
+    }
   }
 
   // Part of final greenery placement.
   public canPlaceGreenery(player: Player): boolean {
     return !this.donePlayers.has(player.id) &&
-            player.plants >= player.plantsNeededForGreenery &&
-            this.board.getAvailableSpacesForGreenery(player).length > 0;
+      player.plants >= player.plantsNeededForGreenery &&
+      this.board.getAvailableSpacesForGreenery(player).length > 0;
   }
 
   // Called when a player has chosen not to place any more greeneries.
@@ -1107,7 +1126,7 @@ export class Game implements ISerializable<SerializedGame> {
     }
 
     // PoliticalAgendas Reds P3 && Magnetic Field Stimulation Delays hook
-    if (increments < 0 ) {
+    if (increments < 0) {
       this.oxygenLevel = Math.max(constants.MIN_OXYGEN_LEVEL, this.oxygenLevel + increments);
       return undefined;
     }
@@ -1235,7 +1254,7 @@ export class Game implements ISerializable<SerializedGame> {
     return this.generation;
   }
 
-  public getPassedPlayers():Array<Color> {
+  public getPassedPlayers(): Array<Color> {
     const passedPlayersColors: Array<Color> = [];
     this.passedPlayers.forEach((player) => {
       passedPlayersColors.push(this.getPlayerById(player).color);
@@ -1318,8 +1337,8 @@ export class Game implements ISerializable<SerializedGame> {
 
     // Hellas special requirements ocean tile
     if (space.id === SpaceName.HELLAS_OCEAN_TILE &&
-        this.canAddOcean() &&
-        this.gameOptions.boardName === BoardName.HELLAS) {
+      this.canAddOcean() &&
+      this.gameOptions.boardName === BoardName.HELLAS) {
       if (player.color !== Color.NEUTRAL) {
         this.defer(new PlaceOceanTile(player, 'Select space for ocean from placement bonus'));
         this.defer(new SelectHowToPayDeferred(player, 6, {title: 'Select how to pay for placement bonus ocean'}));
@@ -1483,7 +1502,7 @@ export class Game implements ISerializable<SerializedGame> {
     for (const p of this.players) {
       if (p.id === this.first.id || insertIdx > 0) {
         ret.splice(insertIdx, 0, p);
-        insertIdx ++;
+        insertIdx++;
       } else {
         ret.push(p);
       }
@@ -1541,12 +1560,12 @@ export class Game implements ISerializable<SerializedGame> {
   public getSpaceByOffset(direction: -1 | 1, toPlace: TileType) {
     const cost = this.discardForCost(toPlace);
 
-    const distance = Math.max(cost-1, 0); // Some cards cost zero.
+    const distance = Math.max(cost - 1, 0); // Some cards cost zero.
     const space = this.board.getNthAvailableLandSpace(distance, direction, undefined /* player */,
       (space) => {
         const adjacentSpaces = this.board.getAdjacentSpaces(space);
         return adjacentSpaces.every((sp) => sp.tile?.tileType !== TileType.CITY) && // no cities nearby
-            adjacentSpaces.some((sp) => this.board.canPlaceTile(sp)); // can place forest nearby
+          adjacentSpaces.some((sp) => this.board.canPlaceTile(sp)); // can place forest nearby
       });
     if (space === undefined) {
       throw new Error('Couldn\'t find space when card cost is ' + cost);
@@ -1661,7 +1680,9 @@ export class Game implements ISerializable<SerializedGame> {
     game.syndicatePirateRaider = d.syndicatePirateRaider;
 
     // Still in Draft or Research of generation 1
-    if (game.generation === 1 && players.some((p) => p.corporationCard === undefined)) {
+    if (game.gameIsOver()) {
+      game.phase = Phase.END;
+    } else if (game.generation === 1 && players.some((p) => p.corporationCard === undefined)) {
       if (game.phase === Phase.INITIALDRAFTING) {
         if (game.initialDraftIteration === 3) {
           game.runDraftRound(true, true);
diff --git a/src/Player.ts b/src/Player.ts
index a001e9447..e93b13493 100644
--- a/src/Player.ts
+++ b/src/Player.ts
@@ -357,9 +357,9 @@ export class Player implements ISerializable<SerializedPlayer> {
   public deductResource(
     resource: Resources,
     amount: number,
-    options? : {
+    options?: {
       log?: boolean,
-      from? : Player | GlobalEventName,
+      from?: Player | GlobalEventName,
       stealing?: boolean
     }) {
     this.addResource(resource, -amount, options);
@@ -368,9 +368,9 @@ export class Player implements ISerializable<SerializedPlayer> {
   public addResource(
     resource: Resources,
     amount: number,
-    options? : {
+    options?: {
       log?: boolean,
-      from? : Player | GlobalEventName,
+      from?: Player | GlobalEventName,
       stealing?: boolean
     }) {
     // When amount is negative, sometimes the amount being asked to be removed is more than the player has.
@@ -425,8 +425,8 @@ export class Player implements ISerializable<SerializedPlayer> {
 
   public addProduction(
     resource: Resources,
-    amount : number,
-    options? : { log: boolean, from? : Player | GlobalEventName, stealing?: boolean},
+    amount: number,
+    options?: {log: boolean, from?: Player | GlobalEventName, stealing?: boolean},
   ) {
     const adj = resource === Resources.MEGACREDITS ? -5 : 0;
     const delta = (amount >= 0) ? amount : Math.max(amount, -(this.getProduction(resource) - adj));
@@ -471,9 +471,9 @@ export class Player implements ISerializable<SerializedPlayer> {
       this.availableHeat - units.heat >= 0;
   }
 
-  public addUnits(units: Partial<Units>, options? : {
+  public addUnits(units: Partial<Units>, options?: {
     log?: boolean,
-    from? : Player | GlobalEventName,
+    from?: Player | GlobalEventName,
   }) {
     this.addResource(Resources.MEGACREDITS, units.megacredits || 0, options);
     this.addResource(Resources.STEEL, units.steel || 0, options);
@@ -560,7 +560,7 @@ export class Player implements ISerializable<SerializedPlayer> {
     // Victory points from milestones
     for (const milestone of this.game.claimedMilestones) {
       if (milestone.player !== undefined && milestone.player.id === this.id) {
-        victoryPointsBreakdown.setVictoryPoints('milestones', 5, 'Claimed '+milestone.milestone.name+' milestone');
+        victoryPointsBreakdown.setVictoryPoints('milestones', 5, 'Claimed ' + milestone.milestone.name + ' milestone');
       }
     }
 
@@ -583,7 +583,7 @@ export class Player implements ISerializable<SerializedPlayer> {
     });
 
     // Turmoil Victory Points
-    const includeTurmoilVP : boolean = this.game.gameIsOver() || this.game.phase === Phase.END;
+    const includeTurmoilVP: boolean = this.game.gameIsOver() || this.game.phase === Phase.END;
 
     Turmoil.ifTurmoil(this.game, (turmoil) => {
       if (includeTurmoilVP) {
@@ -678,7 +678,7 @@ export class Player implements ISerializable<SerializedPlayer> {
     return card.resourceCount;
   }
 
-  public getResourcesOnCorporation():number {
+  public getResourcesOnCorporation(): number {
     if (this.corporationCard !== undefined &&
       this.corporationCard.resourceCount !== undefined) {
       return this.corporationCard.resourceCount;
@@ -689,12 +689,12 @@ export class Player implements ISerializable<SerializedPlayer> {
     let requirementsBonus: number = 0;
     if (
       this.corporationCard !== undefined &&
-          this.corporationCard.getRequirementBonus !== undefined) {
+      this.corporationCard.getRequirementBonus !== undefined) {
       requirementsBonus += this.corporationCard.getRequirementBonus(this, parameter);
     }
     for (const playedCard of this.playedCards) {
       if (playedCard.getRequirementBonus !== undefined &&
-          playedCard.getRequirementBonus(this, parameter)) {
+        playedCard.getRequirementBonus(this, parameter)) {
         requirementsBonus += playedCard.getRequirementBonus(this, parameter);
       }
     }
@@ -707,7 +707,7 @@ export class Player implements ISerializable<SerializedPlayer> {
     return requirementsBonus;
   }
 
-  public removeResourceFrom(card: ICard, count: number = 1, game? : Game, removingPlayer? : Player, shouldLogAction: boolean = true): void {
+  public removeResourceFrom(card: ICard, count: number = 1, game?: Game, removingPlayer?: Player, shouldLogAction: boolean = true): void {
     if (card.resourceCount) {
       card.resourceCount = Math.max(card.resourceCount - count, 0);
       // Mons Insurance hook
@@ -730,13 +730,13 @@ export class Player implements ISerializable<SerializedPlayer> {
   }
 
   public addResourceTo(card: ICard, options: number | {qty?: number, log?: boolean} = 1): void {
-    const count = typeof(options) === 'number' ? options : (options.qty ?? 1);
+    const count = typeof (options) === 'number' ? options : (options.qty ?? 1);
 
     if (card.resourceCount !== undefined) {
       card.resourceCount += count;
     }
 
-    if (typeof(options) !== 'number' && options.log === true) {
+    if (typeof (options) !== 'number' && options.log === true) {
       LogHelper.logAddResource(this, card, count);
     }
 
@@ -770,9 +770,9 @@ export class Player implements ISerializable<SerializedPlayer> {
   public getCardsWithResources(resource?: ResourceType): Array<ICard & IResourceCard> {
     let result: Array<ICard & IResourceCard> = this.playedCards.filter((card) => card.resourceType !== undefined && card.resourceCount && card.resourceCount > 0);
     if (this.corporationCard !== undefined &&
-          this.corporationCard.resourceType !== undefined &&
-          this.corporationCard.resourceCount !== undefined &&
-          this.corporationCard.resourceCount > 0) {
+      this.corporationCard.resourceType !== undefined &&
+      this.corporationCard.resourceCount !== undefined &&
+      this.corporationCard.resourceCount > 0) {
       result.push(this.corporationCard);
     }
 
@@ -879,7 +879,7 @@ export class Player implements ISerializable<SerializedPlayer> {
     let tagCount = 0;
 
     this.playedCards.forEach((card: IProjectCard) => {
-      if ( ! includeEventsTags && card.cardType === CardType.EVENT) return;
+      if (!includeEventsTags && card.cardType === CardType.EVENT) return;
       tagCount += card.tags.filter((cardTag) => cardTag === tag).length;
     });
 
@@ -979,8 +979,9 @@ export class Player implements ISerializable<SerializedPlayer> {
     }
   }
 
-  private parseHowToPayJSON(json: string): HowToPay {
-    const defaults: HowToPay = {
+  private isHowToPay(arg: any): arg is HowToPay {
+    if (typeof arg !== 'object') return false;
+    const template: HowToPay = {
       steel: 0,
       heat: 0,
       titanium: 0,
@@ -990,10 +991,15 @@ export class Player implements ISerializable<SerializedPlayer> {
       science: 0,
       seeds: 0,
     };
+    return Object.keys(template).every((key) =>
+      arg.hasOwnProperty(key) && typeof arg[key] === 'number' && arg[key] >= 0);
+  }
+
+  private parseHowToPayJSON(json: string): HowToPay {
     try {
-      const howToPay: HowToPay = JSON.parse(json);
-      if (Object.keys(howToPay).every((key) => key in defaults) === false) {
-        throw new Error('Input contains unauthorized keys');
+      const howToPay: unknown = JSON.parse(json);
+      if (!this.isHowToPay(howToPay)) {
+        throw new Error('does not match interface');
       }
       return howToPay;
     } catch (err) {
@@ -1001,6 +1007,19 @@ export class Player implements ISerializable<SerializedPlayer> {
     }
   }
 
+  private parseUnitsJSON(json: string): Units {
+    try {
+      const units: unknown = JSON.parse(json);
+      if (!Units.isUnits(units)) {
+        throw new Error('not a units object');
+      }
+
+      return units;
+    } catch (err) {
+      throw new Error('Unable to parse Units input ' + err);
+    }
+  }
+
   protected runInput(input: ReadonlyArray<ReadonlyArray<string>>, pi: PlayerInput): void {
     if (pi instanceof AndOptions) {
       this.checkInputLength(input, pi.options.length);
@@ -1043,10 +1062,12 @@ export class Player implements ISerializable<SerializedPlayer> {
     } else if (pi instanceof SelectHowToPayForProjectCard) {
       this.checkInputLength(input, 1, 2);
       const cardName = input[0][0];
-      const _data = PlayerInput.getCard(pi.cards, cardName);
-      const foundCard: IProjectCard = _data.card;
+      const data = PlayerInput.getCard(pi.cards, cardName);
+      const foundCard: IProjectCard = data.card;
       const howToPay: HowToPay = this.parseHowToPayJSON(input[0][1]);
-      const reserveUnits = pi.reserveUnits[_data.idx];
+      const reserveUnits = pi.reserveUnits[data.idx];
+      // These are not used for safety but do help give a better error message
+      // to the user
       if (reserveUnits.steel + howToPay.steel > this.steel) {
         throw new Error(`${reserveUnits.steel} units of steel must be reserved for ${cardName}`);
       }
@@ -1109,10 +1130,19 @@ export class Player implements ISerializable<SerializedPlayer> {
     } else if (pi instanceof SelectHowToPay) {
       this.checkInputLength(input, 1, 1);
       const howToPay: HowToPay = this.parseHowToPayJSON(input[0][0]);
+      if (!this.canSpend(howToPay)) {
+        throw new Error('You do not have that many resources');
+      }
       this.runInputCb(pi.cb(howToPay));
     } else if (pi instanceof SelectProductionToLose) {
-      // TODO(kberg): I'm sure there's some input validation required.
-      const units: Units = JSON.parse(input[0][0]);
+      this.checkInputLength(input, 1, 1);
+      const units: Units = this.parseUnitsJSON(input[0][0]);
+      if (!Units.keys.every((k) => units[k] >= 0)) {
+        throw new Error('All units must be positive');
+      }
+      if (!this.hasUnits(units)) {
+        throw new Error('You do not have those units');
+      }
       pi.cb(units);
     } else if (pi instanceof ShiftAresGlobalParameters) {
       // TODO(kberg): I'm sure there's some input validation required.
@@ -1137,16 +1167,16 @@ export class Player implements ISerializable<SerializedPlayer> {
   private getPlayableActionCards(): Array<ICard & IActionCard> {
     const result: Array<ICard & IActionCard> = [];
     if (isIActionCard(this.corporationCard) &&
-          !this.actionsThisGeneration.has(this.corporationCard.name) &&
-          isIActionCard(this.corporationCard) &&
-          this.corporationCard.canAct(this)) {
+      !this.actionsThisGeneration.has(this.corporationCard.name) &&
+      isIActionCard(this.corporationCard) &&
+      this.corporationCard.canAct(this)) {
       result.push(this.corporationCard);
     }
     for (const playedCard of this.playedCards) {
       if (
         isIActionCard(playedCard) &&
-              !this.actionsThisGeneration.has(playedCard.name) &&
-              playedCard.canAct(this)) {
+        !this.actionsThisGeneration.has(playedCard.name) &&
+        playedCard.canAct(this)) {
         result.push(playedCard);
       }
     }
@@ -1409,66 +1439,39 @@ export class Player implements ISerializable<SerializedPlayer> {
     );
   }
 
+  private howToPayOptionsForCard(selectedCard: IProjectCard): HowToPay.Options {
+    return {
+      steel: this.canUseSteel(selectedCard),
+      titanium: this.canUseTitanium(selectedCard),
+      seeds: this.canUseSeeds(selectedCard),
+      floaters: this.canUseFloaters(selectedCard),
+      microbes: this.canUseMicrobes(selectedCard),
+      science: this.canUseScience(selectedCard),
+    };
+  }
+
   public checkHowToPayAndPlayCard(selectedCard: IProjectCard, howToPay: HowToPay) {
     const cardCost: number = this.getCardCost(selectedCard);
-    let totalToPay: number = 0;
 
-    const canUseSteel = this.canUseSteel(selectedCard);
-    const canUseTitanium = this.canUseTitanium(selectedCard);
+    const reserved = MoonExpansion.adjustedReserveCosts(this, selectedCard);
 
-    if (canUseSteel && howToPay.steel > 0) {
-      if (howToPay.steel > this.steel) {
-        throw new Error('Do not have enough steel');
-      }
-      totalToPay += howToPay.steel * this.getSteelValue();
-    }
-
-    if (canUseTitanium && howToPay.titanium > 0) {
-      if (howToPay.titanium > this.titanium) {
-        throw new Error('Do not have enough titanium');
-      }
-      totalToPay += howToPay.titanium * this.getTitaniumValue();
-    }
-
-    if (this.canUseHeatAsMegaCredits && howToPay.heat !== undefined) {
-      totalToPay += howToPay.heat;
-    }
-
-    if (howToPay.microbes !== undefined) {
-      totalToPay += howToPay.microbes * DEFAULT_MICROBES_VALUE;
+    if (!this.canSpend(howToPay, reserved)) {
+      throw new Error('You do not have that many resources to spend');
     }
 
-    if (howToPay.floaters !== undefined && howToPay.floaters > 0) {
-      if (selectedCard.name === CardName.STRATOSPHERIC_BIRDS && howToPay.floaters === this.getFloatersCanSpend()) {
-        const cardsWithFloater = this.getCardsWithResources(ResourceType.FLOATER);
-        if (cardsWithFloater.length === 1) {
-          throw new Error('Cannot spend all floaters to play Stratospheric Birds');
-        }
+    if (selectedCard.name === CardName.STRATOSPHERIC_BIRDS && howToPay.floaters === this.getFloatersCanSpend()) {
+      const cardsWithFloater = this.getCardsWithResources(ResourceType.FLOATER);
+      if (cardsWithFloater.length === 1) {
+        throw new Error('Cannot spend all floaters to play Stratospheric Birds');
       }
-      totalToPay += howToPay.floaters * DEFAULT_FLOATERS_VALUE;
     }
 
-    if (howToPay.science ?? 0 > 0) {
-      totalToPay += howToPay.science;
-    }
-
-    if (howToPay.seeds ?? 0 > 0) {
-      totalToPay += howToPay.seeds * constants.SEED_VALUE;
-    }
-
-    if (howToPay.megaCredits > this.megaCredits) {
-      throw new Error('Do not have enough M‚Ç¨');
-    }
-
-    if (howToPay.science !== undefined) {
-      totalToPay += howToPay.science;
-    }
-
-    totalToPay += howToPay.megaCredits;
+    const totalToPay = this.payingAmount(howToPay, this.howToPayOptionsForCard(selectedCard));
 
     if (totalToPay < cardCost) {
       throw new Error('Did not spend enough to pay for card');
     }
+
     return this.playCard(selectedCard, howToPay);
   }
 
@@ -1508,32 +1511,36 @@ export class Player implements ISerializable<SerializedPlayer> {
     return 0;
   }
 
-  public playCard(selectedCard: IProjectCard, howToPay?: HowToPay, addToPlayedCards: boolean = true): undefined {
-    // Pay for card
-    if (howToPay !== undefined) {
-      this.deductResource(Resources.STEEL, howToPay.steel);
-      this.deductResource(Resources.TITANIUM, howToPay.titanium);
-      this.deductResource(Resources.MEGACREDITS, howToPay.megaCredits);
-      this.deductResource(Resources.HEAT, howToPay.heat);
-
-      for (const playedCard of this.playedCards) {
-        if (playedCard.name === CardName.PSYCHROPHILES) {
-          this.removeResourceFrom(playedCard, howToPay.microbes);
-        }
+  public pay(howToPay: HowToPay) {
+    this.deductResource(Resources.STEEL, howToPay.steel);
+    this.deductResource(Resources.TITANIUM, howToPay.titanium);
+    this.deductResource(Resources.MEGACREDITS, howToPay.megaCredits);
+    this.deductResource(Resources.HEAT, howToPay.heat);
 
-        if (playedCard.name === CardName.DIRIGIBLES) {
-          this.removeResourceFrom(playedCard, howToPay.floaters);
-        }
+    for (const playedCard of this.playedCards) {
+      if (playedCard.name === CardName.PSYCHROPHILES) {
+        this.removeResourceFrom(playedCard, howToPay.microbes);
+      }
 
-        if (playedCard.name === CardName.LUNA_ARCHIVES) {
-          this.removeResourceFrom(playedCard, howToPay.science);
-        }
+      if (playedCard.name === CardName.DIRIGIBLES) {
+        this.removeResourceFrom(playedCard, howToPay.floaters);
+      }
 
-        if (this.corporationCard?.name === CardName.SOYLENT_SEEDLING_SYSTEMS) {
-          this.removeResourceFrom(this.corporationCard, howToPay.seeds);
-        }
+      if (playedCard.name === CardName.LUNA_ARCHIVES) {
+        this.removeResourceFrom(playedCard, howToPay.science);
+      }
+
+      if (this.corporationCard?.name === CardName.SOYLENT_SEEDLING_SYSTEMS) {
+        this.removeResourceFrom(this.corporationCard, howToPay.seeds);
       }
     }
+  }
+
+  public playCard(selectedCard: IProjectCard, howToPay?: HowToPay, addToPlayedCards: boolean = true): undefined {
+    // Pay for card
+    if (howToPay !== undefined) {
+      this.pay(howToPay);
+    }
 
     // Activate some colonies
     if (this.game.gameOptions.coloniesExtension && selectedCard.resourceType !== undefined) {
@@ -1659,8 +1666,8 @@ export class Player implements ISerializable<SerializedPlayer> {
     return this.heat + (this.isCorporation(CardName.STORMCRAFT_INCORPORATED) ? this.getResourcesOnCorporation() * 2 : 0);
   }
 
-  public spendHeat(amount: number, cb: () => (undefined | PlayerInput) = () => undefined) : PlayerInput | undefined {
-    if (this.isCorporation(CardName.STORMCRAFT_INCORPORATED) && this.getResourcesOnCorporation() > 0 ) {
+  public spendHeat(amount: number, cb: () => (undefined | PlayerInput) = () => undefined): PlayerInput | undefined {
+    if (this.isCorporation(CardName.STORMCRAFT_INCORPORATED) && this.getResourcesOnCorporation() > 0) {
       return (<StormCraftIncorporated> this.corporationCard).spendHeat(this, amount, cb);
     }
     this.deductResource(Resources.HEAT, amount);
@@ -1668,7 +1675,7 @@ export class Player implements ISerializable<SerializedPlayer> {
   }
 
   private claimMilestone(milestone: IMilestone): SelectOption {
-    return new SelectOption(milestone.name, 'Claim - ' + '('+ milestone.name + ')', () => {
+    return new SelectOption(milestone.name, 'Claim - ' + '(' + milestone.name + ')', () => {
       this.game.claimedMilestones.push({
         player: this,
         milestone: milestone,
@@ -1699,29 +1706,29 @@ export class Player implements ISerializable<SerializedPlayer> {
 
       // We have one rank 1 player
       if (fundedAward.award.getScore(players[0]) > fundedAward.award.getScore(players[1])) {
-        if (players[0].id === this.id) vpb.setVictoryPoints('awards', 5, '1st place for '+fundedAward.award.name+' award (funded by '+fundedAward.player.name+')');
+        if (players[0].id === this.id) vpb.setVictoryPoints('awards', 5, '1st place for ' + fundedAward.award.name + ' award (funded by ' + fundedAward.player.name + ')');
         players.shift();
 
         if (players.length > 1) {
           // We have one rank 2 player
           if (fundedAward.award.getScore(players[0]) > fundedAward.award.getScore(players[1])) {
-            if (players[0].id === this.id) vpb.setVictoryPoints('awards', 2, '2nd place for '+fundedAward.award.name+' award (funded by '+fundedAward.player.name+')');
+            if (players[0].id === this.id) vpb.setVictoryPoints('awards', 2, '2nd place for ' + fundedAward.award.name + ' award (funded by ' + fundedAward.player.name + ')');
 
-          // We have at least two rank 2 players
+            // We have at least two rank 2 players
           } else {
             const score = fundedAward.award.getScore(players[0]);
             while (players.length > 0 && fundedAward.award.getScore(players[0]) === score) {
-              if (players[0].id === this.id) vpb.setVictoryPoints('awards', 2, '2nd place for '+fundedAward.award.name+' award (funded by '+fundedAward.player.name+')');
+              if (players[0].id === this.id) vpb.setVictoryPoints('awards', 2, '2nd place for ' + fundedAward.award.name + ' award (funded by ' + fundedAward.player.name + ')');
               players.shift();
             }
           }
         }
 
-      // We have at least two rank 1 players
+        // We have at least two rank 1 players
       } else {
         const score = fundedAward.award.getScore(players[0]);
         while (players.length > 0 && fundedAward.award.getScore(players[0]) === score) {
-          if (players[0].id === this.id) vpb.setVictoryPoints('awards', 5, '1st place for '+fundedAward.award.name+' award (funded by '+fundedAward.player.name+')');
+          if (players[0].id === this.id) vpb.setVictoryPoints('awards', 5, '1st place for ' + fundedAward.award.name + ' award (funded by ' + fundedAward.player.name + ')');
           players.shift();
         }
       }
@@ -1824,12 +1831,7 @@ export class Player implements ISerializable<SerializedPlayer> {
     const canAfford = this.canAfford(
       baseCost,
       {
-        steel: this.canUseSteel(card),
-        titanium: this.canUseTitanium(card),
-        floaters: this.canUseFloaters(card),
-        microbes: this.canUseMicrobes(card),
-        science: this.canUseScience(card),
-        seeds: this.canUseSeeds(card),
+        ...this.howToPayOptionsForCard(card),
         reserveUnits: MoonExpansion.adjustedReserveCosts(this, card),
         tr: card.tr,
       });
@@ -1850,50 +1852,78 @@ export class Player implements ISerializable<SerializedPlayer> {
     return card.canPlay(this);
   }
 
+  private maxSpendable(reserveUnits: Units = Units.EMPTY): HowToPay {
+    return {
+      megaCredits: this.megaCredits - reserveUnits.megacredits,
+      steel: this.steel - reserveUnits.steel,
+      titanium: this.titanium - reserveUnits.titanium,
+      heat: this.heat - reserveUnits.heat,
+      floaters: this.getFloatersCanSpend(),
+      microbes: this.getMicrobesCanSpend(),
+      science: this.getSpendableScienceResources(),
+      seeds: this.getSpendableSeedResources(),
+    };
+  }
+
+  public canSpend(howToPay: HowToPay, reserveUnits?: Units): boolean {
+    const maxPayable = this.maxSpendable(reserveUnits);
+
+    return HowToPay.keys.every((key) =>
+      0 <= howToPay[key] && howToPay[key] <= maxPayable[key]);
+  }
+
+  private payingAmount(howToPay: HowToPay, options?: HowToPay.Options): number {
+    const mult: {[key in keyof HowToPay]: number} = {
+      megaCredits: 1,
+      steel: this.getSteelValue(),
+      titanium: this.getTitaniumValue(),
+      heat: 1,
+      microbes: DEFAULT_MICROBES_VALUE,
+      floaters: DEFAULT_FLOATERS_VALUE,
+      science: 1,
+      seeds: constants.SEED_VALUE,
+    };
+
+    const usable: {[key in keyof HowToPay]: boolean} = {
+      megaCredits: true,
+      steel: options?.steel ?? false,
+      titanium: options?.titanium ?? false,
+      heat: this.canUseHeatAsMegaCredits,
+      microbes: options?.microbes ?? false,
+      floaters: options?.floaters ?? false,
+      science: options?.science ?? false,
+      seeds: options?.seeds ?? false,
+    };
+
+    let totalToPay = 0;
+    for (const key of HowToPay.keys) {
+      if (usable[key]) totalToPay += howToPay[key] * mult[key];
+    }
+
+    return totalToPay;
+  }
+
   // Checks if the player can afford to pay `cost` mc (possibly replaceable with steel, titanium etc.)
   // and additionally pay the reserveUnits (no replaces here)
-  public canAfford(cost: number, options?: {
-    steel?: boolean,
-    titanium?: boolean,
-    floaters?: boolean,
-    microbes?: boolean,
-    science?: boolean,
-    seeds?: boolean,
-    reserveUnits?: Units,
-    tr?: TRSource,
-  }) {
+  public canAfford(cost: number, options?: CanAffordOptions) {
     const reserveUnits = options?.reserveUnits ?? Units.EMPTY;
     if (!this.hasUnits(reserveUnits)) {
       return false;
     }
 
-    const canUseSteel: boolean = options?.steel ?? false;
-    const canUseTitanium: boolean = options?.titanium ?? false;
-    const canUseFloaters: boolean = options?.floaters ?? false;
-    const canUseMicrobes: boolean = options?.microbes ?? false;
-    const canUseScience: boolean = options?.science ?? false;
-    const canUseSeeds: boolean = options?.seeds ?? false;
+    const maxPayable = this.maxSpendable(reserveUnits);
 
     const redsCost = TurmoilHandler.computeTerraformRatingBump(this, options?.tr) * REDS_RULING_POLICY_COST;
-
-    let availableMegacredits = this.megaCredits;
-    if (this.canUseHeatAsMegaCredits) {
-      availableMegacredits += this.heat;
-      availableMegacredits -= reserveUnits.heat;
+    if (redsCost > 0) {
+      const usableForRedsCost = this.payingAmount(maxPayable, {});
+      if (usableForRedsCost < redsCost) {
+        return false;
+      }
     }
-    availableMegacredits -= reserveUnits.megacredits;
-    availableMegacredits -= redsCost;
 
-    if (availableMegacredits < 0) {
-      return false;
-    }
-    return cost <= availableMegacredits +
-      (canUseSteel ? (this.steel - reserveUnits.steel) * this.getSteelValue() : 0) +
-      (canUseTitanium ? (this.titanium - reserveUnits.titanium) * this.getTitaniumValue() : 0) +
-      (canUseFloaters ? this.getFloatersCanSpend() * 3 : 0) +
-      (canUseMicrobes ? this.getMicrobesCanSpend() * 2 : 0) +
-      (canUseScience ? this.getSpendableScienceResources() : 0) +
-      (canUseSeeds ? this.getSpendableSeedResources() * constants.SEED_VALUE : 0);
+    const usable = this.payingAmount(maxPayable, options);
+
+    return cost + redsCost <= usable;
   }
 
   private getStandardProjects(): Array<StandardProjectCard> {
@@ -1904,7 +1934,7 @@ export class Player implements ISerializable<SerializedPlayer> {
         // sell patents is not displayed as a card
         case CardName.SELL_PATENTS_STANDARD_PROJECT:
           return false;
-        // For buffer gas, show ONLY IF in solo AND 63TR mode
+          // For buffer gas, show ONLY IF in solo AND 63TR mode
         case CardName.BUFFER_GAS_STANDARD_PROJECT:
           return this.game.isSoloMode() && this.game.gameOptions.soloTR;
         case CardName.AIR_SCRAPPING_STANDARD_PROJECT:
@@ -1987,9 +2017,9 @@ export class Player implements ISerializable<SerializedPlayer> {
     }
 
     if (corporationCard !== undefined &&
-          corporationCard.initialAction !== undefined &&
-          corporationCard.initialActionText !== undefined &&
-          this.corporationInitialActionDone === false
+      corporationCard.initialAction !== undefined &&
+      corporationCard.initialActionText !== undefined &&
+      this.corporationInitialActionDone === false
     ) {
       const initialActionOption = new SelectOption(
         {
@@ -2382,3 +2412,8 @@ export class Player implements ISerializable<SerializedPlayer> {
     return unavailableColonies < availableColonyTiles.length;
   }
 }
+
+interface CanAffordOptions extends HowToPay.Options {
+  reserveUnits?: Units,
+  tr?: TRSource,
+}
diff --git a/src/SerializedChallenge.ts b/src/SerializedChallenge.ts
new file mode 100644
index 000000000..0e168b0b6
--- /dev/null
+++ b/src/SerializedChallenge.ts
@@ -0,0 +1,9 @@
+import {ChallengeId, GameId} from './common/Types';
+
+export interface SerializedChallenge {
+    id: ChallengeId;
+    active: GameId | undefined;
+    won: Array<GameId>;
+    lost: Array<GameId>;
+}
+
diff --git a/src/SerializedGame.ts b/src/SerializedGame.ts
index 45f6b490a..25bacbc40 100644
--- a/src/SerializedGame.ts
+++ b/src/SerializedGame.ts
@@ -10,7 +10,7 @@ import {SerializedColony} from './SerializedColony';
 import {SerializedPlayer} from './SerializedPlayer';
 import {SerializedDealer} from './SerializedDealer';
 import {SerializedTurmoil} from './turmoil/SerializedTurmoil';
-import {PlayerId, GameId, SpectatorId} from './common/Types';
+import {PlayerId, GameId, SpectatorId, ChallengeId} from './common/Types';
 import {GameOptions} from './Game';
 import {IAresData} from './ares/IAresData';
 import {LogMessage} from './common/logs/LogMessage';
@@ -59,5 +59,6 @@ export interface SerializedGame {
     undoCount: number;
     unDraftedCards: Array<[PlayerId, Array<CardName>]>;
     venusScaleLevel: number;
+    challenge?: ChallengeId;
 }
 
diff --git a/src/Units.ts b/src/Units.ts
index 2b98195c7..2100178f1 100644
--- a/src/Units.ts
+++ b/src/Units.ts
@@ -43,6 +43,14 @@ export namespace Units {
     },
   };
 
+  export const keys = Object.keys(EMPTY) as (keyof Units)[];
+
+  export function isUnits(arg: any): arg is Units {
+    if (typeof arg !== 'object') return false;
+    return keys.every(key =>
+      typeof arg[key] === 'number' && !isNaN(arg[key]));
+  }
+
   // Converts partial units to a full Units, allowing code to use a Units stricture,
   // reducing the need to check for undefined everywhere.
   export function of(partialUnits: Partial<Units>): Units {
diff --git a/src/client/components/App.ts b/src/client/components/App.ts
index 15757b4e9..0c3e7f82c 100644
--- a/src/client/components/App.ts
+++ b/src/client/components/App.ts
@@ -7,6 +7,7 @@ import PlayerInputFactory from '@/client/components/PlayerInputFactory.vue';
 import SpectatorHome from '@/client/components/SpectatorHome.vue';
 import {ViewModel, PlayerViewModel} from '@/models/PlayerModel';
 import StartScreen from '@/client/components/StartScreen.vue';
+import StartChallengeScreen from '@/client/components/StartChallenge.vue';
 import LoadGameForm from '@/client/components/LoadGameForm.vue';
 import DebugUI from '@/client/components/DebugUI.vue';
 import {SimpleGameModel} from '@/models/SimpleGameModel';
@@ -23,33 +24,34 @@ import {hasShowModal, showModal, windowHasHTMLDialogElement} from './HTMLDialogE
 const dialogPolyfill = require('dialog-polyfill');
 
 interface MainAppData {
-    screen: 'create-game-form' |
-            'cards' |
-            'empty' |
-            'game-home' |
-            'games-overview' |
-            'help' |
-            'load' |
-            'player-home' |
-            'spectator-home' |
-            'start-screen' |
-            'the-end';
-    /**
-     * player or spectator are set once the app component has loaded.
-     * Vue only watches properties that exist initially. When we
-     * use this property we can't trigger vue state without
-     * a refactor.
-     */
-    spectator?: SpectatorModel;
-    playerView?: PlayerViewModel;
-    // playerKey might seem to serve no function, but it's basically an arbitrary value used
-    // to force a rerender / refresh.
-    // See https://michaelnthiessen.com/force-re-render/
-    playerkey: number;
-    settings: typeof raw_settings;
-    isServerSideRequestInProgress: boolean;
-    componentsVisibility: {[x: string]: boolean};
-    game: SimpleGameModel | undefined;
+  screen: 'create-game-form' |
+  'cards' |
+  'empty' |
+  'game-home' |
+  'games-overview' |
+  'help' |
+  'load' |
+  'player-home' |
+  'spectator-home' |
+  'start-screen' |
+  'start-challenge' |
+  'the-end';
+  /**
+   * player or spectator are set once the app component has loaded.
+   * Vue only watches properties that exist initially. When we
+   * use this property we can't trigger vue state without
+   * a refactor.
+   */
+  spectator?: SpectatorModel;
+  playerView?: PlayerViewModel;
+  // playerKey might seem to serve no function, but it's basically an arbitrary value used
+  // to force a rerender / refresh.
+  // See https://michaelnthiessen.com/force-re-render/
+  playerkey: number;
+  settings: typeof raw_settings;
+  isServerSideRequestInProgress: boolean;
+  componentsVisibility: {[x: string]: boolean};
+  game: SimpleGameModel | undefined;
 }
 
 export const mainAppSettings = {
@@ -80,6 +82,7 @@ export const mainAppSettings = {
     'player-input-factory': PlayerInputFactory,
     'start-screen': StartScreen,
     'create-game-form': CreateGameForm,
+    'start-challenge': StartChallengeScreen,
     'load-game-form': LoadGameForm,
     'game-home': GameHome,
     'player-home': PlayerHome,
@@ -229,6 +232,8 @@ export const mainAppSettings = {
       app.screen = 'help';
     } else if (currentPathname === '/spectator') {
       app.updateSpectator();
+    } else if (currentPathname === '/challenge-info') {
+      app.screen = 'start-challenge';
     } else {
       app.screen = 'start-screen';
     }
diff --git a/src/client/components/GameEnd.vue b/src/client/components/GameEnd.vue
index 8261bd9f6..e87d2ea4e 100644
--- a/src/client/components/GameEnd.vue
+++ b/src/client/components/GameEnd.vue
@@ -2,6 +2,21 @@
         <div id="game-end" class="game_end_cont">
             <h1>{{ constants.APP_NAME }} - Game finished!</h1>
             <div class="game_end">
+                <div class="challenge-game-end" v-if="game.challenge && playerView">
+                  <h2>Planets done: {{ game.challenge.games }}</h2>
+                  <a v-if="game.challenge.games >= constants.CHALLENGE_GAMES"
+                    v-on:click="getFlag()"
+                    class="start-screen-link start-screen-link--solo">
+                    Get üèÅ
+                  </a>
+                  <a v-else v-on:click="continueChallenge()"
+                    class="start-screen-link start-screen-link--solo">
+                    Continue
+                  </a>
+                  <div v-if="flag" class="challenge-flag">
+                    {{ flag }}
+                  </div>
+                </div>
                 <div v-if="isSoloGame()">
                     <div v-if="game.isSoloModeWin">
                         <div class="game_end_success">
@@ -211,6 +226,7 @@ export default Vue.extend({
   data() {
     return {
       constants,
+      flag: undefined,
     };
   },
   components: {
@@ -253,6 +269,29 @@ export default Vue.extend({
     isSoloGame(): boolean {
       return this.players.length === 1;
     },
+    getFlag() {
+      fetch('/flag?id=' + this.game.challenge?.id, {
+        method: 'GET',
+      })
+        .then((response) =>
+          response.ok ? response.json() : response.text())
+        .then((data) => {
+          this.$data.flag = data?.flag ?? data;
+        })
+        .catch((e) => alert('No flag for you: ' + e));
+    },
+    continueChallenge() {
+      fetch('/challenge', {
+        method: 'POST',
+        body: JSON.stringify({action: 'continue', id: this.game.challenge?.id}),
+        headers: {'Content-Type': 'application/json'},
+      })
+        .then((response) => response.json())
+        .then((data) => {
+          window.location.href = '/player?id=' + data.playerId;
+        })
+        .catch((_) => alert('Unexpected server response'));
+    },
   },
 });
 
diff --git a/src/client/components/PlayerHome.vue b/src/client/components/PlayerHome.vue
index 82ab97d68..d917cb2f6 100644
--- a/src/client/components/PlayerHome.vue
+++ b/src/client/components/PlayerHome.vue
@@ -20,6 +20,7 @@
         :venus = "game.venusScaleLevel"
         :turmoil = "game.turmoil"
         :moonData="game.moon"
+        :challenge="game.challenge"
         :gameOptions = "game.gameOptions"
         :playerNumber = "playerView.players.length"
         :lastSoloGeneration = "game.lastSoloGeneration">
diff --git a/src/client/components/Sidebar.vue b/src/client/components/Sidebar.vue
index 51a08f64e..21e110966 100644
--- a/src/client/components/Sidebar.vue
+++ b/src/client/components/Sidebar.vue
@@ -1,5 +1,8 @@
 <template>
 <div :class="'sidebar_cont sidebar '+getSideBarClass()">
+  <div v-if="challenge" class="challenge-status">
+    <span class="challenge-games">{{ challenge.games }}</span>
+  </div>
   <div class="tm">
     <div class="gen-text">GEN</div>
     <div class="gen-marker">{{ getGenMarker() }}</div>
@@ -83,6 +86,7 @@ import MoonGlobalParameterValue from '@/client/components/MoonGlobalParameterVal
 import {GlobalParameter} from '@/GlobalParameter';
 import {MoonModel} from '@/models/MoonModel';
 import PreferencesDialog from '@/client/components/PreferencesDialog.vue';
+import {ChallengeModel} from '@/models/ChallengeModel';
 
 export default Vue.extend({
   name: 'sidebar',
@@ -90,6 +94,9 @@ export default Vue.extend({
     playerNumber: {
       type: Number,
     },
+    challenge: {
+      type: Object as () => ChallengeModel | undefined,
+    },
     gameOptions: {
       type: Object as () => GameOptionsModel,
     },
diff --git a/src/client/components/SpectatorHome.vue b/src/client/components/SpectatorHome.vue
index 0da5aee27..4e36c4773 100644
--- a/src/client/components/SpectatorHome.vue
+++ b/src/client/components/SpectatorHome.vue
@@ -11,6 +11,7 @@
       :venus = "game.venusScaleLevel"
       :turmoil = "game.turmoil"
       :moonData="game.moon"
+      :challenge="game.challenge"
       :gameOptions = "game.gameOptions"
       :playerNumber = "spectator.players.length"
       :lastSoloGeneration = "game.lastSoloGeneration">
diff --git a/src/client/components/StartChallenge.vue b/src/client/components/StartChallenge.vue
new file mode 100644
index 000000000..e88fe70ef
--- /dev/null
+++ b/src/client/components/StartChallenge.vue
@@ -0,0 +1,45 @@
+<template>
+<div class="start-challenge">
+  <h1>Challenge</h1>
+  <p>
+    As it turns out, there are {{ constants.CHALLENGE_GAMES }} planets that need
+    help. Maybe once you've helped all of them, you'll be able to get your
+    colonist's flag.
+  </p>
+  <a v-on:click="begin()" class="start-screen-link start-screen-link--solo">Begin</a>
+</div>
+</template>
+
+<script lang="ts">
+
+import Vue from 'vue';
+import * as constants from '@/constants';
+
+export default Vue.extend({
+  name: 'start-challenge',
+  props: {
+  },
+  data() {
+    return {
+      constants,
+    };
+  },
+  components: {
+  },
+  methods: {
+    begin() {
+      fetch('/challenge', {
+        method: 'POST',
+        body: JSON.stringify({action: 'start'}),
+        headers: {'Content-Type': 'application/json'},
+      })
+        .then((response) => response.json())
+        .then((data) => {
+          window.location.href = '/player?id=' + data.playerId;
+        })
+        .catch((_) => alert('Unexpected server response'));
+    },
+  },
+});
+
+</script>
diff --git a/src/client/components/StartScreen.vue b/src/client/components/StartScreen.vue
index fa98ad015..10e0e40bc 100644
--- a/src/client/components/StartScreen.vue
+++ b/src/client/components/StartScreen.vue
@@ -6,12 +6,12 @@
       <div class="start-screen-title-bottom">MARS</div>
     </div>
     <a class="start-screen-link start-screen-link--new-game" href="/new-game" v-i18n>New game</a>
-    <a class="start-screen-link start-screen-link--solo" href="/solo" v-i18n>Solo challenge</a>
+    <a class="start-screen-link start-screen-link--solo" href="/challenge-info" v-i18n>Challenge</a>
     <a class="start-screen-link start-screen-link--cards-list" href="/cards" target="_blank" v-i18n>Cards list</a>
     <a class="start-screen-link start-screen-link--board-game" href="https://boardgamegeek.com/boardgame/167791/terraforming-mars" target="_blank" v-i18n>Board game</a>
-    <a class="start-screen-link start-screen-link--about" href="https://github.com/bafolts/terraforming-mars#README" target="_blank" v-i18n>About us</a>
-    <a class="start-screen-link start-screen-link--changelog" href="https://github.com/bafolts/terraforming-mars/wiki/Changelog" target="_blank" v-i18n>Whats new?</a>
-    <a class="start-screen-link start-screen-link--chat" href="https://discord.gg/VR8TbrD" target="_blank" v-i18n>Join us on Discord</a>
+    <a class="start-screen-link start-screen-link--about" href="https://www.youtube.com/watch?v=PvKiWRTSAzg" target="_blank" v-i18n>About us</a>
+    <a class="start-screen-link start-screen-link--changelog" href="https://www.youtube.com/watch?v=PvKiWRTSAzg" target="_blank" v-i18n>Whats new?</a>
+    <a class="start-screen-link start-screen-link--chat" href="https://discord.com/invite/SpvHFdASf9" target="_blank" v-i18n>Join us on Discord</a>
     <div class="start-screen-header start-screen-link--languages">
       <language-switcher />
       <div class="start-screen-version-cont">
diff --git a/src/common/Types.ts b/src/common/Types.ts
index 94374a66e..7e010b86d 100644
--- a/src/common/Types.ts
+++ b/src/common/Types.ts
@@ -1,4 +1,5 @@
 export type PlayerId = string;
 export type GameId = string;
+export type ChallengeId = string;
 export type SpectatorId = string;
 
diff --git a/src/constants.ts b/src/constants.ts
index edfb2139f..bb590e5af 100644
--- a/src/constants.ts
+++ b/src/constants.ts
@@ -50,6 +50,9 @@ export const DEFAULT_ESCAPE_VELOCITY_THRESHOLD = 30;
 export const DEFAULT_ESCAPE_VELOCITY_PERIOD = 2;
 export const DEFAULT_ESCAPE_VELOCITY_PENALTY = 1;
 
+// Challenge
+export const CHALLENGE_GAMES = 256;
+
 export const LANGUAGES = [
   {'id': 'en', 'title': 'English'},
   {'id': 'de', 'title': 'German'},
diff --git a/src/database/ChallengeLoader.ts b/src/database/ChallengeLoader.ts
new file mode 100644
index 000000000..c24368bab
--- /dev/null
+++ b/src/database/ChallengeLoader.ts
@@ -0,0 +1,49 @@
+import {Database} from './Database';
+import {ChallengeId} from '../common/Types';
+import {Challenge} from '../Challenge';
+
+export class ChallengeLoader {
+  private static instance?: ChallengeLoader;
+
+  private byId: Map<ChallengeId, Challenge> = new Map();
+  private loading: Map<ChallengeId, Promise<Challenge | undefined>> = new Map();
+
+  private constructor() {
+  }
+
+  public static getInstance(): ChallengeLoader {
+    if (ChallengeLoader.instance === undefined) {
+      ChallengeLoader.instance = new ChallengeLoader();
+    }
+    return ChallengeLoader.instance;
+  }
+
+  public add(challenge: Challenge): void {
+    const old = this.byId.get(challenge.id);
+    if (old !== challenge) {
+      throw new Error('BUG: Challenge with duplicate id');
+    }
+    this.byId.set(challenge.id, challenge);
+  }
+
+  private async load(id: ChallengeId): Promise<Challenge | undefined> {
+    const serialized = await Database.getInstance().getChallenge(id).catch(() => undefined);
+    if (!serialized) {
+      return undefined;
+    }
+    const challenge = await Challenge.deserialize(serialized);
+    this.byId.set(id, challenge);
+    return challenge;
+  }
+
+  public async getByChallengeId(id: ChallengeId): Promise<Challenge | undefined> {
+    if (this.byId.has(id)) {
+      return this.byId.get(id);
+    } else if (this.loading.has(id)) {
+      return this.loading.get(id);
+    }
+    const result = this.load(id);
+    this.loading.set(id, result);
+    return result;
+  }
+}
diff --git a/src/database/GameIds.ts b/src/database/GameIds.ts
index 89e8e7063..a23296b9c 100644
--- a/src/database/GameIds.ts
+++ b/src/database/GameIds.ts
@@ -3,12 +3,23 @@ import {Game} from '../Game';
 import {PlayerId, GameId, SpectatorId} from '../common/Types';
 import {once} from 'events';
 import {EventEmitter} from 'events';
+import {MultiMap} from 'mnemonist';
+
+type StoredGame = { game: Game | undefined, lastAccess: number };
+type Unloader = { timeout: NodeJS.Timeout, scheduledFor: number };
+
+const EVICT_AFTER_MS =
+  Math.max(10000, Number(process.env.EVICT_GAMES_AFTER_MS ?? 300000));
+
+type ParticipantId = PlayerId | SpectatorId;
 
 export class GameIds extends EventEmitter {
   private loaded = false;
-  private readonly games = new Map<GameId, Game | undefined>();
-  private readonly participantIds = new Map<SpectatorId | PlayerId, GameId>();
-  private getInstance(gameId: GameId) : Promise<void> {
+  private unloader: Unloader | undefined = undefined;
+  private readonly games = new Map<GameId, StoredGame>();
+  private readonly participantIds = new Map<ParticipantId, GameId>();
+
+  private getInstance(gameId: GameId): Promise<void> {
     return new Promise<void>((resolve) => {
       Database.getInstance().getGame(
         gameId,
@@ -18,13 +29,9 @@ export class GameIds extends EventEmitter {
           } else {
             console.log(`load game ${gameId} with ${game.spectatorId}`);
             if (this.games.get(gameId) === undefined) {
-              this.games.set(gameId, undefined);
-              if (game.spectatorId !== undefined) {
-                this.participantIds.set(game.spectatorId, gameId);
-              }
-              for (const player of game.players) {
-                this.participantIds.set(player.id, gameId);
-              }
+              const participants = game.players.map((p) => p.id);
+              if (game.spectatorId) participants.push(game.spectatorId);
+              this.addId(gameId, participants);
             }
           }
           resolve();
@@ -32,31 +39,120 @@ export class GameIds extends EventEmitter {
     });
   }
 
-  private async getAllInstances(allGameIds: Array<GameId>) : Promise<void[]> {
+  private async getAllInstances(allGameIds: Array<GameId>): Promise<void[]> {
     return Promise.all(allGameIds.map((x) => {
       return this.getInstance(x);
     }));
   }
 
-  public load() : void {
-    Database.getInstance().getGames((err, allGameIds) => {
-      if (err) {
-        console.error('error loading all games', err);
-        this.loaded = true;
-        this.emit('loaded');
-        return;
+  private async doUnload() {
+    this.unloader = undefined;
+    const now = Date.now();
+    let evictedAny = false;
+    for (let it = this.games.entries(), value = it.next(); !value.done; value = it.next()) {
+      await Promise.resolve();
+      const stored = value.value[1];
+      if (now - stored.lastAccess > EVICT_AFTER_MS && stored.game) {
+        stored.game = undefined;
+        stored.lastAccess = Infinity;
+        evictedAny = true;
       }
-      this.getAllInstances(allGameIds).then(() =>{
-        this.loaded = true;
-        this.emit('loaded');
+    }
+    if (evictedAny) {
+      this.scheduleUnloading(now);
+    }
+  }
+
+  private scheduleUnloading(now: number) {
+    if (!this.unloader) {
+      this.unloader = {
+        scheduledFor: now + EVICT_AFTER_MS * 2,
+        timeout: setTimeout(() => this.doUnload(), EVICT_AFTER_MS * 2),
+      };
+    } else if (this.unloader.scheduledFor < now) {
+      clearTimeout(this.unloader.timeout);
+      this.doUnload();
+    }
+  }
+
+  public add(game: Game) {
+    const stored = this.games.get(game.id);
+    const now = Date.now();
+    if (!stored) {
+      this.games.set(game.id, {game, lastAccess: now});
+    } else {
+      stored.game = game;
+      stored.lastAccess = now;
+    }
+    if (game.spectatorId) {
+      this.participantIds.set(game.spectatorId, game.id);
+    }
+    game.getPlayers().forEach((p) => this.participantIds.set(p.id, game.id));
+    this.scheduleUnloading(now);
+  }
+
+  public addId(gameId: GameId, participants: Array<ParticipantId>) {
+    const stored = this.games.get(gameId);
+    if (!stored) {
+      this.games.set(gameId, {game: undefined, lastAccess: Infinity});
+    }
+    participants.forEach((p) => this.participantIds.set(p, gameId));
+  }
+
+  public load(): void {
+    Database.getInstance().getGamesAndParticipants().then((games) => {
+      games.forEach((game) => {
+        const [gameId, participants] = game;
+        this.addId(gameId, participants);
+      });
+      this.loaded = true;
+      this.emit('loaded');
+    }).catch((err) => {
+      console.log('error loading games fast', err);
+      Database.getInstance().getGames((err, allGameIds) => {
+        if (err) {
+          console.error('error loading all games', err);
+          this.loaded = true;
+          this.emit('loaded');
+          return;
+        }
+        this.getAllInstances(allGameIds).then(() => {
+          this.loaded = true;
+          this.emit('loaded');
+        });
       });
     });
   }
 
-  public async getGames(): Promise<{games:Map<GameId, Game | undefined>, participantIds:Map<SpectatorId | PlayerId, GameId>}> {
+  public async getAll(): Promise<Array<{id: GameId, participants: Array<ParticipantId>}>> {
+    if (!this.loaded) {
+      await once(this, 'loaded');
+    }
+    const map = new MultiMap<GameId, ParticipantId>();
+    this.participantIds.forEach((gameId, participantId) => map.set(gameId, participantId));
+    const arry: Array<[string, Array<string>]> = Array.from(map.associations());
+    return arry.map(([id, participants]) => ({id: id, participants: participants}));
+  }
+
+  public async getGameForParticipant(id: ParticipantId): Promise<GameId | undefined> {
+    if (!this.loaded) {
+      await once(this, 'loaded');
+    }
+    return this.participantIds.get(id);
+  }
+
+  public async getGame(gameId: GameId): Promise<Game | 'unknown' | 'unloaded'> {
     if (!this.loaded) {
       await once(this, 'loaded');
     }
-    return {games: this.games, participantIds: this.participantIds};
+    const stored = this.games.get(gameId);
+    if (stored === undefined) {
+      return 'unknown';
+    }
+    if (stored.game === undefined) {
+      return 'unloaded';
+    }
+    stored.lastAccess = Date.now();
+    return stored.game;
   }
 }
diff --git a/src/database/GameLoader.ts b/src/database/GameLoader.ts
index 3f8d46a09..782bf0b8c 100644
--- a/src/database/GameLoader.ts
+++ b/src/database/GameLoader.ts
@@ -3,7 +3,8 @@ import {Game} from '../Game';
 import {PlayerId, GameId, SpectatorId} from '../common/Types';
 import {IGameLoader} from './IGameLoader';
 import {GameIds} from './GameIds';
-import {MultiMap} from 'mnemonist';
+import {SerializedGame} from '../SerializedGame';
+import {ChallengeLoader} from './ChallengeLoader';
 
 type LoadCallback = (game: Game | undefined) => void;
 type ListLoadCallback = (list: Array<{id: GameId, participants: Array<SpectatorId | PlayerId>}> | undefined) => void;
@@ -34,48 +35,25 @@ export class GameLoader implements IGameLoader {
   }
 
   public add(game: Game): void {
-    this.idsContainer.getGames().then( (d) => {
-      d.games.set(game.id, game);
-      if (game.spectatorId !== undefined) {
-        d.participantIds.set(game.spectatorId, game.id);
-      }
-      for (const player of game.getPlayers()) {
-        d.participantIds.set(player.id, game.id);
-      }
-    });
+    this.idsContainer.add(game);
   }
 
   public getLoadedGameIds(cb: ListLoadCallback): void {
-    this.idsContainer.getGames().then( (d) => {
-      const map = new MultiMap<GameId, SpectatorId | PlayerId>();
-      d.participantIds.forEach((gameId, participantId) => map.set(gameId, participantId));
-      const arry: Array<[string, Array<string>]> = Array.from(map.associations());
-      cb(arry.map(([id, participants]) => ({id: id, participants: participants})));
-    });
+    this.idsContainer.getAll().then(cb);
   }
 
   public getByGameId(gameId: GameId, bypassCache: boolean, cb: LoadCallback): void {
-    this.idsContainer.getGames().then( (d) => {
-      if (bypassCache === false && d.games.get(gameId) !== undefined) {
-        cb(d.games.get(gameId));
-      } else if (d.games.has(gameId)) {
-        this.loadGame(gameId, bypassCache, cb);
-      } else {
-        cb(undefined);
-      }
-    });
+    this.loadGame(gameId, bypassCache).then(cb);
   }
 
   private getByParticipantId(id: PlayerId | SpectatorId, cb: LoadCallback): void {
-    this.idsContainer.getGames().then( (d) => {
-      const gameId = d.participantIds.get(id);
-      if (gameId !== undefined && d.games.get(gameId) !== undefined) {
-        cb(d.games.get(gameId));
-      } else if (gameId !== undefined) {
-        this.loadParticipant(id, cb);
-      } else {
+    this.idsContainer.getGameForParticipant(id).then((gameId) => {
+      if (gameId === undefined) {
+        console.warn(`GameLoader:id not found ${id}`);
         cb(undefined);
+        return;
       }
+      return this.getByGameId(gameId, false, cb);
     });
   }
 
@@ -109,48 +87,40 @@ export class GameLoader implements IGameLoader {
     }
   }
 
-  private loadGame(gameId: GameId, bypassCache: boolean, cb: LoadCallback): void {
-    this.idsContainer.getGames().then( (d) => {
-      if (bypassCache === false && d.games.get(gameId) !== undefined) {
-        cb(d.games.get(gameId));
-      } else if (d.games.has(gameId) === false) {
-        console.warn(`GameLoader:game id not found ${gameId}`);
-        cb(undefined);
-      } else {
-        Database.getInstance().getGame(gameId, (err: any, serializedGame?) => {
-          if (err || (serializedGame === undefined)) {
-            console.error('GameLoader:loadGame', err);
-            cb(undefined);
-            return;
-          }
-          try {
-            const game = Game.deserialize(serializedGame);
-            this.add(game);
-            console.log(`GameLoader loaded game ${gameId} into memory from database`);
-            cb(game);
-          } catch (e) {
-            console.error('GameLoader:loadGame', e);
-            cb(undefined);
-            return;
-          }
-        });
-      }
+  private async loadGame(gameId: GameId, bypassCache: boolean): Promise<Game | undefined> {
+    const game = await this.idsContainer.getGame(gameId);
+    if (game === 'unknown') {
+      console.warn(`GameLoader:game id not found ${gameId}`);
+      return undefined;
+    } else if (game !== 'unloaded' && bypassCache === false) {
+      return game;
+    }
+
+    const serializedGame = await new Promise<SerializedGame | undefined>((resolve) => {
+      Database.getInstance().getGame(gameId, (err: any, serializedGame?) => {
+        if (err || (serializedGame === undefined)) {
+          console.error('GameLoader:loadGame', err);
+          resolve(undefined);
+          return;
+        } else {
+          resolve(serializedGame);
+        }
+      });
     });
-  }
 
-  private loadParticipant(id: PlayerId | SpectatorId, cb: LoadCallback): void {
-    this.idsContainer.getGames().then( (d) => {
-      const gameId = d.participantIds.get(id);
-      if (gameId === undefined) {
-        console.warn(`GameLoader:id not found ${id}`);
-        cb(undefined);
-        return;
-      }
-      if (d.games.get(gameId) !== undefined) {
-        cb(d.games.get(gameId));
-        return;
+    if (!serializedGame) return undefined;
+
+    try {
+      const game = Game.deserialize(serializedGame);
+      if (serializedGame.challenge) {
+        game.challenge = await ChallengeLoader.getInstance().getByChallengeId(serializedGame.challenge);
       }
-      this.loadGame(gameId, false, cb);
-    });
+      this.add(game);
+
+      return game;
+    } catch (e) {
+      console.error('GameLoader:loadGame', gameId, e);
+      return;
+    }
   }
 }
diff --git a/src/database/IDatabase.ts b/src/database/IDatabase.ts
index f6e8a2bf3..fd652d0af 100644
--- a/src/database/IDatabase.ts
+++ b/src/database/IDatabase.ts
@@ -1,6 +1,7 @@
 import {Game, GameOptions, Score} from '../Game';
-import {GameId} from '../common/Types';
+import {GameId, PlayerId, SpectatorId} from '../common/Types';
 import {SerializedGame} from '../SerializedGame';
+import {SerializedChallenge} from '@/SerializedChallenge';
 
 export interface IGameData {
     gameId: GameId;
@@ -48,6 +49,9 @@ export interface IDatabase {
      */
     initialize(): Promise<void>;
 
+    getChallenge(challenge_id: string): Promise<SerializedChallenge>;
+    saveChallenge(challenge: SerializedChallenge): void;
+
     /**
      * Pulls most recent version of game
      * @param game_id the game id to load
@@ -78,7 +82,9 @@ export interface IDatabase {
      *
      * @param cb a callback either returning either an error or a list of all `game_id`s.
      */
-    getGames(cb:(err: Error | undefined, allGames:Array<GameId>) => void): void;
+    getGames(cb: (err: Error | undefined, allGames: Array<GameId>) => void): void;
+
+    getGamesAndParticipants(): Promise<Array<[GameId, Array<SpectatorId | PlayerId>]>>
 
     /**
      * Load references to all games that can be cloned. Every game is cloneable,
@@ -91,7 +97,7 @@ export interface IDatabase {
      * @param cb a callback either returning either an error or a list of references
      * to cloneable games.
      */
-    getClonableGames(cb:(err: Error | undefined, allGames:Array<IGameData>)=> void) : void;
+    getClonableGames(cb: (err: Error | undefined, allGames: Array<IGameData>) => void): void;
 
     /**
      * Saves the current state of the game. at a supplied save point. Used for
diff --git a/src/database/LocalFilesystem.ts b/src/database/LocalFilesystem.ts
index 4acba515b..db6d0e867 100644
--- a/src/database/LocalFilesystem.ts
+++ b/src/database/LocalFilesystem.ts
@@ -4,6 +4,7 @@ import {GameId} from '../common/Types';
 import {IGameData} from './IDatabase';
 import {SerializedGame} from '../SerializedGame';
 import {Dirent} from 'fs';
+import {SerializedChallenge} from '@/SerializedChallenge';
 
 const path = require('path');
 const fs = require('fs');
@@ -34,6 +35,14 @@ export class Localfilesystem implements IDatabase {
     return path.resolve(historyFolder, `${gameId}-${saveIdString}.json`);
   }
 
+  getChallenge(_challenge_id: string): Promise<SerializedChallenge> {
+    return new Promise((_, reject) => reject(new Error('Unsupported operation: getChallenge')));
+  }
+
+  saveChallenge(_challenge: SerializedChallenge) {
+    // Unsupported
+  }
+
   saveGame(game: Game): Promise<void> {
     console.log(`saving ${game.id} at position ${game.lastSaveId}`);
     this.saveSerializedGame(game.serialize());
@@ -109,6 +118,10 @@ export class Localfilesystem implements IDatabase {
     cb(undefined, gameIds);
   }
 
+  getGamesAndParticipants(): Promise<any> {
+    return new Promise((_, reject) => reject(new Error('Unsupported operation: getGamesAndParticipants')));
+  }
+
   restoreReferenceGame(_gameId: GameId, cb: DbLoadCallback<Game>) {
     cb(new Error('Does not work'), undefined);
   }
diff --git a/src/database/PostgreSQL.ts b/src/database/PostgreSQL.ts
index 3cbc8527e..0634cdd75 100644
--- a/src/database/PostgreSQL.ts
+++ b/src/database/PostgreSQL.ts
@@ -5,6 +5,7 @@ import {IGameData} from './IDatabase';
 import {SerializedGame} from '../SerializedGame';
 
 import {Pool, ClientConfig, QueryResult} from 'pg';
+import {SerializedChallenge} from '@/SerializedChallenge';
 
 export class PostgreSQL implements IDatabase {
   private client: Pool;
@@ -43,6 +44,14 @@ export class PostgreSQL implements IDatabase {
     });
   }
 
+  getChallenge(_challenge_id: string): Promise<SerializedChallenge> {
+    return new Promise((_, reject) => reject(new Error('Unsupported operation: getChallenge')));
+  }
+
+  saveChallenge(_challenge: SerializedChallenge) {
+    // Unsupported
+  }
+
   async initialize(): Promise<void> {
 
   }
@@ -86,6 +95,10 @@ export class PostgreSQL implements IDatabase {
     });
   }
 
+  getGamesAndParticipants(): Promise<any> {
+    return new Promise((_, reject) => reject(new Error('Unsupported operation: getGamesAndParticipants')));
+  }
+
   loadCloneableGame(game_id: GameId, cb: DbLoadCallback<SerializedGame>) {
     // Retrieve first save from database
     this.client.query('SELECT game_id game_id, game game FROM games WHERE game_id = $1 AND save_id = 0', [game_id], (err: Error | undefined, res) => {
diff --git a/src/database/SQLite.ts b/src/database/SQLite.ts
index 461ff9f66..7203ec39c 100644
--- a/src/database/SQLite.ts
+++ b/src/database/SQLite.ts
@@ -1,10 +1,11 @@
 import {DbLoadCallback, IDatabase} from './IDatabase';
 import {Game, GameOptions, Score} from '../Game';
-import {GameId} from '../common/Types';
+import {GameId, PlayerId, SpectatorId} from '../common/Types';
 import {IGameData} from './IDatabase';
 import {SerializedGame} from '../SerializedGame';
 
 import sqlite3 = require('sqlite3');
+import {SerializedChallenge} from '@/SerializedChallenge';
 const path = require('path');
 const fs = require('fs');
 const dbFolder = path.resolve(process.cwd(), './db');
@@ -25,33 +26,50 @@ export class SQLite implements IDatabase {
   }
 
   initialize(): Promise<void> {
-    return new Promise((resolve, reject) => {
+    return (new Promise<void>((resolve, reject) => {
       this.db.run('CREATE TABLE IF NOT EXISTS games(game_id varchar, players integer, save_id integer, game text, status text default \'running\', created_time timestamp default (strftime(\'%s\', \'now\')), PRIMARY KEY (game_id, save_id))', (err) => {
         if (err) {
           reject(err);
           return;
         }
-        this.db.run('CREATE TABLE IF NOT EXISTS game_results(game_id varchar not null, seed_game_id varchar, players integer, generations integer, game_options text, scores text, PRIMARY KEY (game_id))', (err2) => {
-          if (err2) {
-            reject(err2);
-            return;
-          }
-          this.db.run(`
+        resolve();
+      });
+    })).then(() => new Promise<void>((resolve, reject) => {
+      this.db.run('CREATE TABLE IF NOT EXISTS game_results(game_id varchar not null, seed_game_id varchar, players integer, generations integer, game_options text, scores text, PRIMARY KEY (game_id))', (err2) => {
+        if (err2) {
+          reject(err2);
+          return;
+        }
+        resolve();
+      });
+    })).then(() => new Promise<void>((resolve, reject) => {
+      this.db.run(`
           CREATE TABLE IF NOT EXISTS purges(
             game_id varchar not null,
             last_save_id number not null,
             completed_time timestamp not null default (strftime('%s', 'now')),
             PRIMARY KEY (game_id)
           )`, (err3) => {
-            if (err3) {
-              reject(err3);
-              return;
-            }
-            resolve();
-          });
-        });
+        if (err3) {
+          reject(err3);
+          return;
+        }
+        resolve();
       });
-    });
+    })).then(() => new Promise<void>((resolve, reject) => {
+      this.db.run(`
+        CREATE TABLE IF NOT EXISTS challenges(
+          challenge_id varchar not null,
+          challenge text,
+          PRIMARY KEY (challenge_id)
+        )`, (err) => {
+        if (err) {
+          reject(err);
+        } else {
+          resolve();
+        }
+      });
+    }));
   }
 
   getClonableGames(cb: (err: Error | undefined, allGames: Array<IGameData>) => void) {
@@ -87,9 +105,39 @@ export class SQLite implements IDatabase {
     });
   }
 
+  async getGamesAndParticipants(): Promise<Array<[GameId, Array<PlayerId|SpectatorId>]>> {
+    const sql: string = `
+    SELECT
+      g.game_id game,
+      json_extract(g.game, '$.spectatorId') spectator,
+      json_group_array(json_extract(p.value, '$.id')) players
+    FROM
+      games g, json_each(g.game, '$.players') p
+    WHERE
+      g.save_id = 0
+    GROUP BY
+      g.game_id
+    `;
+
+    return new Promise((resolve, reject) => {
+      this.db.all(sql, (err, rows: Array<{game: GameId, spectator: SpectatorId|null, players: string}>) => {
+        if (err) {
+          reject(err);
+          return;
+        }
+        const combined = rows.map((row) => {
+          const participants: Array<PlayerId|SpectatorId> = JSON.parse(row.players);
+          if (row.spectator) participants.push(row.spectator);
+          return [row.game, participants] as [GameId, Array<PlayerId|SpectatorId>];
+        });
+        resolve(combined);
+      });
+    });
+  }
+
   loadCloneableGame(game_id: GameId, cb: DbLoadCallback<SerializedGame>) {
     // Retrieve first save from database
-    this.db.get('SELECT game_id game_id, game game FROM games WHERE game_id = ? AND save_id = 0', [game_id], (err: Error | null, row: { game_id: GameId, game: any; }) => {
+    this.db.get('SELECT game_id game_id, game game FROM games WHERE game_id = ? AND save_id = 0', [game_id], (err: Error | null, row: {game_id: GameId, game: any;}) => {
       if (row.game_id === undefined) {
         return cb(new Error('Game not found'), undefined);
       }
@@ -106,6 +154,26 @@ export class SQLite implements IDatabase {
     });
   }
 
+  getChallenge(challenge_id: string): Promise<SerializedChallenge> {
+    return new Promise((resolve, reject) => {
+      this.db.get('SELECT challenge FROM challenges WHERE challenge_id = ?',
+        [challenge_id], (err: Error | null, row: {challenge: string}) => {
+          if (err) {
+            return reject(err);
+          }
+          resolve(JSON.parse(row.challenge));
+        });
+    });
+  }
+
+  saveChallenge(challenge: SerializedChallenge) {
+    const text = JSON.stringify(challenge);
+    this.runQuietly(`
+       INSERT INTO challenges (challenge_id, challenge) VALUES (?, ?)
+        ON CONFLICT(challenge_id) DO UPDATE SET challenge = ?
+    `, [challenge.id, text, text]);
+  }
+
   saveGameResults(game_id: GameId, players: number, generations: number, gameOptions: GameOptions, scores: Array<Score>): void {
     this.db.run(
       'INSERT INTO game_results (game_id, seed_game_id, players, generations, game_options, scores) VALUES($1, $2, $3, $4, $5, $6)',
@@ -120,7 +188,7 @@ export class SQLite implements IDatabase {
 
   getGame(game_id: GameId, cb: (err: Error | undefined, game?: SerializedGame) => void): void {
     // Retrieve last save from database
-    this.db.get('SELECT game game FROM games WHERE game_id = ? ORDER BY save_id DESC LIMIT 1', [game_id], (err: Error | null, row: { game: any; }) => {
+    this.db.get('SELECT game game FROM games WHERE game_id = ? ORDER BY save_id DESC LIMIT 1', [game_id], (err: Error | null, row: {game: any;}) => {
       if (err) {
         return cb(err ?? undefined);
       }
@@ -131,7 +199,7 @@ export class SQLite implements IDatabase {
   // TODO(kberg): throw an error if two game ids exist.
   getGameId(playerId: string, cb: (err: Error | undefined, gameId?: GameId) => void): void {
     const sql = 'SELECT game_id from games, json_each(games.game, \'$.players\') e where json_extract(e.value, \'$.id\') = ?';
-    this.db.get(sql, [playerId], (err: Error | null, row: { gameId: any; }) => {
+    this.db.get(sql, [playerId], (err: Error | null, row: {gameId: any;}) => {
       if (err) {
         return cb(err ?? undefined);
       }
@@ -140,7 +208,7 @@ export class SQLite implements IDatabase {
   }
 
   getGameVersion(game_id: GameId, save_id: number, cb: DbLoadCallback<SerializedGame>): void {
-    this.db.get('SELECT game game FROM games WHERE game_id = ? and save_id = ?', [game_id, save_id], (err: Error | null, row: { game: any; }) => {
+    this.db.get('SELECT game game FROM games WHERE game_id = ? and save_id = ?', [game_id, save_id], (err: Error | null, row: {game: any;}) => {
       if (err) {
         return cb(err ?? undefined, undefined);
       }
@@ -149,7 +217,7 @@ export class SQLite implements IDatabase {
   }
 
   getMaxSaveId(game_id: GameId, cb: DbLoadCallback<number>): void {
-    this.db.get('SELECT MAX(save_id) AS save_id FROM games WHERE game_id = ?', [game_id], (err: Error | null, row: { save_id: number; }) => {
+    this.db.get('SELECT MAX(save_id) AS save_id FROM games WHERE game_id = ?', [game_id], (err: Error | null, row: {save_id: number;}) => {
       if (err) {
         return cb(err ?? undefined, undefined);
       }
@@ -187,7 +255,7 @@ export class SQLite implements IDatabase {
 
   restoreGame(game_id: GameId, save_id: number, cb: DbLoadCallback<Game>): void {
     // Retrieve last save from database
-    this.db.get('SELECT game game FROM games WHERE game_id = ? AND save_id = ? ORDER BY save_id DESC LIMIT 1', [game_id, save_id], (err: Error | null, row: { game: any; }) => {
+    this.db.get('SELECT game game FROM games WHERE game_id = ? AND save_id = ? ORDER BY save_id DESC LIMIT 1', [game_id, save_id], (err: Error | null, row: {game: any;}) => {
       if (err) {
         console.error(err.message);
         cb(err, undefined);
diff --git a/src/deferredActions/SelectHowToPayDeferred.ts b/src/deferredActions/SelectHowToPayDeferred.ts
index 4e2615967..f1fb7d8dc 100644
--- a/src/deferredActions/SelectHowToPayDeferred.ts
+++ b/src/deferredActions/SelectHowToPayDeferred.ts
@@ -7,9 +7,9 @@ import {Resources} from '../common/Resources';
 export class SelectHowToPayDeferred implements DeferredAction {
   public priority = Priority.DEFAULT;
   constructor(
-        public player: Player,
-        public amount: number,
-        public options: SelectHowToPayDeferred.Options = {},
+    public player: Player,
+    public amount: number,
+    public options: SelectHowToPayDeferred.Options = {},
   ) {}
 
   private mustPayWithMegacredits() {
@@ -45,13 +45,10 @@ export class SelectHowToPayDeferred implements DeferredAction {
       this.options.canUseSeeds || false,
       this.amount,
       (howToPay: HowToPay) => {
-        this.player.deductResource(Resources.STEEL, howToPay.steel);
-        this.player.deductResource(Resources.TITANIUM, howToPay.titanium);
-        this.player.deductResource(Resources.MEGACREDITS, howToPay.megaCredits);
-        this.player.deductResource(Resources.HEAT, howToPay.heat);
-        if (howToPay.seeds > 0 && this.player.corporationCard !== undefined) {
-          this.player.removeResourceFrom(this.player.corporationCard, howToPay.seeds);
+        if (!this.player.canSpend(howToPay)) {
+          throw new Error('You do not have that many resources to spend');
         }
+        this.player.pay(howToPay);
         if (this.options.afterPay !== undefined) {
           this.options.afterPay();
         }
diff --git a/src/inputs/HowToPay.ts b/src/inputs/HowToPay.ts
index 1c737cea9..bb9a99acb 100644
--- a/src/inputs/HowToPay.ts
+++ b/src/inputs/HowToPay.ts
@@ -10,3 +10,18 @@ export interface HowToPay {
     seeds: number;
 }
 
+export namespace HowToPay {
+    export const EMPTY: Readonly<HowToPay> = {
+      heat: 0, megaCredits: 0, steel: 0, titanium: 0, microbes: 0, floaters: 0, science: 0, seeds: 0,
+    };
+    export const keys = Object.keys(EMPTY) as (keyof HowToPay)[];
+
+    export interface Options {
+        steel?: boolean,
+        titanium?: boolean,
+        floaters?: boolean,
+        microbes?: boolean,
+        science?: boolean,
+        seeds?: boolean,
+    };
+}
diff --git a/src/models/ChallengeModel.ts b/src/models/ChallengeModel.ts
new file mode 100644
index 000000000..141e541fe
--- /dev/null
+++ b/src/models/ChallengeModel.ts
@@ -0,0 +1,6 @@
+import {ChallengeId} from '@/common/Types';
+
+export interface ChallengeModel {
+  games: number,
+  id: ChallengeId,
+}
diff --git a/src/models/GameModel.ts b/src/models/GameModel.ts
index a97ac1a35..bf81bb6a0 100644
--- a/src/models/GameModel.ts
+++ b/src/models/GameModel.ts
@@ -9,6 +9,7 @@ import {SpaceModel} from './SpaceModel';
 import {IAresData} from '../ares/IAresData';
 import {MoonModel} from './MoonModel';
 import {PathfindersModel} from './PathfindersModel';
+import {ChallengeModel} from './ChallengeModel';
 
 // Common data about a game not assocaited with a player (eg the temperature.)
 export interface GameModel {
@@ -36,4 +37,5 @@ export interface GameModel {
   turmoil: TurmoilModel | undefined;
   undoCount: number;
   venusScaleLevel: number;
+  challenge?: ChallengeModel;
 }
diff --git a/src/models/ServerModel.ts b/src/models/ServerModel.ts
index 6dd009690..1e513e821 100644
--- a/src/models/ServerModel.ts
+++ b/src/models/ServerModel.ts
@@ -44,6 +44,8 @@ import {SelectPartyToSendDelegate} from '../inputs/SelectPartyToSendDelegate';
 import {GameModel} from './GameModel';
 import {Turmoil} from '../turmoil/Turmoil';
 import {PathfindersModel} from './PathfindersModel';
+import {Challenge} from '../Challenge';
+import {ChallengeModel} from './ChallengeModel';
 
 export class Server {
   public static getSimpleGameModel(game: Game): SimpleGameModel {
@@ -62,6 +64,13 @@ export class Server {
     };
   }
 
+  public static getChallengeModel(challenge: Challenge): ChallengeModel {
+    return {
+      id: challenge.id,
+      games: challenge.won.length,
+    };
+  }
+
   public static getGameModel(game: Game): GameModel {
     const turmoil = getTurmoilModel(game);
 
@@ -90,6 +99,7 @@ export class Server {
       undoCount: game.undoCount,
       venusScaleLevel: game.getVenusScaleLevel(),
       step: game.lastSaveId,
+      challenge: game.challenge && this.getChallengeModel(game.challenge),
     };
   }
 
@@ -354,11 +364,11 @@ export class Server {
     player: Player,
     cards: Array<ICard>,
     options: {
-    showResources?: boolean,
-    showNewCost?: boolean,
-    reserveUnits?: Array<Units>,
-    enabled?: Array<boolean>, // If provided, then the cards with false in `enabled` are not selectable and grayed out
-  } = {},
+      showResources?: boolean,
+      showNewCost?: boolean,
+      reserveUnits?: Array<Units>,
+      enabled?: Array<boolean>, // If provided, then the cards with false in `enabled` are not selectable and grayed out
+    } = {},
   ): Array<CardModel> {
     return cards.map((card, index) => ({
       resources: options.showResources ? player.getResourcesOnCard(card) : undefined,
@@ -445,7 +455,7 @@ export class Server {
   public static getColor(space: ISpace): Color | undefined {
     if (
       (space.tile === undefined || space.tile.tileType !== TileType.OCEAN) &&
-    space.player !== undefined
+      space.player !== undefined
     ) {
       return space.player.color;
     }
diff --git a/src/routes/BodyLog.ts b/src/routes/BodyLog.ts
new file mode 100644
index 000000000..024f4b5aa
--- /dev/null
+++ b/src/routes/BodyLog.ts
@@ -0,0 +1,64 @@
+import {createWriteStream, WriteStream} from 'fs';
+import * as http from 'http';
+
+interface Message {
+  ctx: BodyLog.ParseCtx;
+  kind: string;
+}
+
+export class BodyLog {
+  private static instance?: BodyLog;
+
+  private _log?: WriteStream;
+  private index: number = 0;
+
+  private constructor(file?: string) {
+    if (file) this._log = createWriteStream(file, {flags: 'a'});
+  }
+
+  public static initialize(file: string) {
+    if (BodyLog.instance) throw new Error('BodyLog already initialized');
+    this.instance = new BodyLog(file);
+  }
+
+  public static getInstance(): BodyLog {
+    if (!this.instance) this.instance = new BodyLog();
+    return this.instance;
+  }
+
+  private log<T extends Message>(message: T) {
+    this._log?.write(JSON.stringify(message) + '\n');
+  }
+
+  public parseAndLog(
+    req: http.IncomingMessage,
+    body: string,
+  ): BodyLog.ParseResult {
+    if (body.length > 2000) {
+      return {kind: 'error', message: 'Request too large'};
+    }
+
+    const ctx: BodyLog.ParseCtx = [new Date(), this.index++];
+
+    let parsed;
+    try {
+      parsed = JSON.parse(body);
+    } catch (e) {
+      const message = e instanceof Error ? e.message : String(e);
+      return {kind: 'error', message};
+    }
+
+    this.log({ctx, kind: 'body', url: req.url, body: parsed});
+    return {kind: 'ok', ctx, data: parsed};
+  }
+
+  public addMessage(ctx: BodyLog.ParseCtx, message: any) {
+    this.log({ctx, kind: 'msg', message});
+  }
+}
+
+export namespace BodyLog {
+  export type ParseCtx = [Date, number];
+  export type ParseOk = { kind: 'ok', data: any, ctx: ParseCtx };
+  export type ParseResult = ParseOk | { kind: 'error', message: string };
+}
diff --git a/src/routes/Challenge.ts b/src/routes/Challenge.ts
new file mode 100644
index 000000000..24d0bca5e
--- /dev/null
+++ b/src/routes/Challenge.ts
@@ -0,0 +1,189 @@
+import * as http from 'http';
+import * as constants from '../constants';
+import {Handler} from './Handler';
+import {IContext} from './IHandler';
+import {BoardName, RandomBoardOption} from '../boards/BoardName';
+import {GameLoader} from '../database/GameLoader';
+import {Game, GameOptions} from '../Game';
+import {Player} from '../Player';
+import {Color} from '../Color';
+import {AgendaStyle} from '../turmoil/PoliticalAgendas';
+import {RandomMAOptionType} from '../RandomMAOptionType';
+import {Challenge} from '../Challenge';
+import {GameHandler} from './Game';
+import {ChallengeLoader} from '../database/ChallengeLoader';
+import {BodyLog} from './BodyLog';
+
+export class ChallengeHandler extends Handler {
+  public static readonly INSTANCE = new ChallengeHandler();
+  private constructor() {
+    super();
+  }
+
+  public static boardOptions(board: string) {
+    const allBoards = Object.values(BoardName);
+
+    if (board === RandomBoardOption.ALL) return allBoards;
+    if (board === RandomBoardOption.OFFICIAL) return allBoards.filter((name) => name !== BoardName.ARABIA_TERRA);
+    return [board];
+  }
+
+  private newGame(challenge: Challenge): Game {
+    const gameId = GameHandler.INSTANCE.generateRandomId('g');
+    const spectatorId = GameHandler.INSTANCE.generateRandomId('s');
+    const players = [
+      new Player(
+        'Pwner',
+        Color.RED,
+        false,
+        0, // For some reason handicap is coming up a string.
+        GameHandler.INSTANCE.generateRandomId('p'),
+      ),
+    ];
+
+    const firstPlayerIdx: number = 0;
+
+    const gameOptions: GameOptions = {
+      // cdeboor: Should we vary the board name?
+      boardName: BoardName.ORIGINAL,
+      clonedGamedId: undefined,
+
+      undoOption: false,
+
+      corporateEra: true,
+      draftVariant: true,
+      initialDraftVariant: false,
+      randomMA: RandomMAOptionType.NONE,
+      showOtherPlayersVP: false,
+      preludeExtension: true,
+      venusNextExtension: false,
+      coloniesExtension: false,
+      turmoilExtension: false,
+      customCorporationsList: [],
+      customColoniesList: [],
+      cardsBlackList: [],
+      solarPhaseOption: false,
+      shuffleMapOption: false,
+      promoCardsOption: false,
+      communityCardsOption: false,
+      aresExtension: false,
+      aresHazards: true, // Not a runtime option.
+      politicalAgendasExtension: AgendaStyle.STANDARD,
+      moonExpansion: false,
+      pathfindersExpansion: false,
+      showTimers: true,
+      fastModeOption: false,
+      removeNegativeGlobalEventsOption: false,
+      includeVenusMA: true,
+      startingCorporations: 2,
+      soloTR: false,
+      requiresVenusTrackCompletion: false,
+      requiresMoonTrackCompletion: false,
+      moonStandardProjectVariant: false,
+      altVenusBoard: false,
+      escapeVelocityMode: false,
+      escapeVelocityThreshold: constants.DEFAULT_ESCAPE_VELOCITY_THRESHOLD,
+      escapeVelocityPeriod: constants.DEFAULT_ESCAPE_VELOCITY_PERIOD,
+      escapeVelocityPenalty: constants.DEFAULT_ESCAPE_VELOCITY_PENALTY,
+    };
+
+    const seed = Math.random();
+    const game = Game.newInstance(gameId, players, players[firstPlayerIdx], gameOptions, seed, spectatorId, challenge);
+    GameLoader.getInstance().add(game);
+
+    if (challenge.active) {
+      throw new Error('BUG: Tried to create a new game while one was already active.');
+    }
+    challenge.active = game.id;
+    challenge.save();
+
+    return game;
+  }
+
+  private async doGet(req: http.IncomingMessage, res: http.ServerResponse, ctx: IContext): Promise<void> {
+    const challengeId = ctx.url.searchParams.get('id');
+    if (!challengeId) {
+      ctx.route.notFound(req, res, 'id parameter missing');
+      return;
+    }
+
+    const challenge = await ChallengeLoader.getInstance().getByChallengeId(challengeId);
+    if (!challenge) {
+      ctx.route.notFound(req, res, 'invalid challenge id');
+      return;
+    }
+
+    if (challenge.active) {
+      ctx.route.notFound(req, res, `you still have a planet in progress`);
+    } else if (challenge.lost.length > 1) {
+      // we allow a single grace game
+      ctx.route.notFound(req, res, `you failed ${challenge.lost.length} planets`);
+    } else if (challenge.won.length < constants.CHALLENGE_GAMES) {
+      ctx.route.notFound(req, res,
+        `did not finish the challenge yet: ${constants.CHALLENGE_GAMES - challenge.lost.length} planets left`);
+    } else {
+      ctx.route.writeJson(res, {flag: process.env.FLAG});
+    }
+  }
+
+  public override get(req: http.IncomingMessage, res: http.ServerResponse, ctx: IContext): void {
+    this.doGet(req, res, ctx);
+  }
+
+  public override post(req: http.IncomingMessage, res: http.ServerResponse, ctx: IContext): void {
+    let body = '';
+    req.on('data', function(data) {
+      body += data.toString();
+    });
+    req.once('end', async () => {
+      const parsed = BodyLog.getInstance().parseAndLog(req, body);
+      if (parsed.kind === 'error') {
+        ctx.route.badRequest(req, res, parsed.message);
+        return;
+      }
+      try {
+        const data = parsed.data;
+
+        let challenge: Challenge;
+        if (data.action === 'start') {
+          challenge = new Challenge(GameHandler.INSTANCE.generateRandomId('c'));
+        } else if (data.action === 'continue') {
+          if (typeof data.id === 'string') {
+            const loaded = await ChallengeLoader.getInstance().getByChallengeId(data.id);
+            if (!loaded) {
+              ctx.route.badRequest(req, res, 'Invalid challenge id');
+              return;
+            }
+            challenge = loaded;
+          } else {
+            ctx.route.badRequest(req, res);
+            return;
+          }
+        } else {
+          ctx.route.badRequest(req, res);
+          return;
+        }
+
+        let game;
+        if (challenge.active) {
+          const gameId = challenge.active;
+          game = await new Promise<Game|undefined>((resolve) =>
+            GameLoader.getInstance().getByGameId(gameId, true, resolve));
+          if (!game) {
+            ctx.route.notFound(req, res, 'Invalid challenge. Try starting a new one.');
+            return;
+          }
+          if (game.gameIsOver()) {
+            throw new Error('BUG: Finished game is active');
+          }
+        } else {
+          game = this.newGame(challenge);
+        }
+
+        ctx.route.writeJson(res, {playerId: game.getPlayerById(game.activePlayer).id});
+      } catch (error) {
+        ctx.route.internalServerError(req, res, error);
+      }
+    });
+  }
+}
diff --git a/src/routes/Game.ts b/src/routes/Game.ts
index dfa5d42ba..a52a9a6b0 100644
--- a/src/routes/Game.ts
+++ b/src/routes/Game.ts
@@ -9,6 +9,7 @@ import {Game, GameOptions} from '../Game';
 import {Player} from '../Player';
 import {Server} from '../models/ServerModel';
 import {ServeAsset} from './ServeAsset';
+import {BodyLog} from './BodyLog';
 
 // Oh, this could be called Game, but that would introduce all kinds of issues.
 
@@ -21,8 +22,9 @@ export class GameHandler extends Handler {
   }
 
   public generateRandomId(prefix: string): string {
-    // 281474976710656 possible values.
-    return prefix + Math.floor(Math.random() * Math.pow(16, 12)).toString(16);
+    return prefix +
+      Math.floor(Math.random() * Math.pow(16, 12)).toString(16) +
+      Math.floor(Math.random() * Math.pow(16, 12)).toString(16);
   }
 
   public static boardOptions(board: string) {
@@ -46,8 +48,13 @@ export class GameHandler extends Handler {
       body += data.toString();
     });
     req.once('end', () => {
+      const parsed = BodyLog.getInstance().parseAndLog(req, body);
+      if (parsed.kind === 'error') {
+        ctx.route.badRequest(req, res, parsed.message);
+        return;
+      }
       try {
-        const gameReq = JSON.parse(body);
+        const gameReq = parsed.data;
         const gameId = this.generateRandomId('g');
         const spectatorId = this.generateRandomId('s');
         const players = gameReq.players.map((obj: any) => {
diff --git a/src/routes/LoadGame.ts b/src/routes/LoadGame.ts
index 22c23fbff..652aca6d6 100644
--- a/src/routes/LoadGame.ts
+++ b/src/routes/LoadGame.ts
@@ -1,10 +1,10 @@
 import * as http from 'http';
-import {Database} from '../database/Database';
 import {GameLoader} from '../database/GameLoader';
 import {Server} from '../models/ServerModel';
 import {Handler} from './Handler';
 import {IContext} from './IHandler';
 import {LoadGameFormModel} from '../models/LoadGameFormModel';
+import {BodyLog} from './BodyLog';
 
 export class LoadGame extends Handler {
   public static readonly INSTANCE = new LoadGame();
@@ -18,15 +18,21 @@ export class LoadGame extends Handler {
       body += data.toString();
     });
     req.once('end', () => {
+      const parsed = BodyLog.getInstance().parseAndLog(req, body);
+      if (parsed.kind === 'error') {
+        ctx.route.badRequest(req, res, parsed.message);
+        return;
+      }
       try {
-        const gameReq: LoadGameFormModel = JSON.parse(body);
+        const gameReq: LoadGameFormModel = parsed.data;
 
         const game_id = gameReq.game_id;
         // This should probably be behind some kind of verification that prevents just
         // anyone from rolling back a large number of steps.
         const rollbackCount = gameReq.rollbackCount;
         if (rollbackCount > 0) {
-          Database.getInstance().deleteGameNbrSaves(game_id, rollbackCount);
+          ctx.route.badRequest(req, res, 'unable to roll back');
+          return;
         }
         GameLoader.getInstance().getByGameId(game_id, true, (game) => {
           if (game === undefined) {
diff --git a/src/routes/PlayerInput.ts b/src/routes/PlayerInput.ts
index 1612be40a..9bd3f1a4c 100644
--- a/src/routes/PlayerInput.ts
+++ b/src/routes/PlayerInput.ts
@@ -6,6 +6,7 @@ import {Handler} from './Handler';
 import {IContext} from './IHandler';
 import {OrOptions} from '../inputs/OrOptions';
 import {UndoActionOption} from '../inputs/UndoActionOption';
+import {BodyLog} from './BodyLog';
 
 export class PlayerInput extends Handler {
   public static readonly INSTANCE = new PlayerInput();
@@ -76,8 +77,13 @@ export class PlayerInput extends Handler {
       body += data.toString();
     });
     req.once('end', () => {
+      const parsed = BodyLog.getInstance().parseAndLog(req, body);
+      if (parsed.kind === 'error') {
+        ctx.route.badRequest(req, res, parsed.message);
+        return;
+      }
       try {
-        const entity = JSON.parse(body);
+        const entity = parsed.data;
         if (this.isWaitingForUndo(player, entity)) {
           this.performUndo(res, ctx, player);
           return;
@@ -89,8 +95,8 @@ export class PlayerInput extends Handler {
           'Content-Type': 'application/json',
         });
 
-        console.warn('Error processing input from player', e);
         const message = e instanceof Error ? e.message : String(e);
+        BodyLog.getInstance().addMessage(parsed.ctx, message);
         res.write(JSON.stringify({message}));
         res.end();
       }
diff --git a/src/server.ts b/src/server.ts
index 5d15a1e39..6936b1fa0 100644
--- a/src/server.ts
+++ b/src/server.ts
@@ -26,6 +26,8 @@ import {Route} from './routes/Route';
 import {PlayerInput} from './routes/PlayerInput';
 import {ServeApp} from './routes/ServeApp';
 import {ServeAsset} from './routes/ServeAsset';
+import {ChallengeHandler} from './routes/Challenge';
+import {BodyLog} from './routes/BodyLog';
 
 process.on('uncaughtException', (err: any) => {
   console.error('UNCAUGHT EXCEPTION', err);
@@ -58,6 +60,9 @@ const handlers: Map<string, IHandler> = new Map(
     ['/player', ServeApp.INSTANCE],
     ['/player/input', PlayerInput.INSTANCE],
     ['/solo', ServeApp.INSTANCE],
+    ['/challenge-info', ServeApp.INSTANCE],
+    ['/challenge', ChallengeHandler.INSTANCE],
+    ['/flag', ChallengeHandler.INSTANCE],
     ['/spectator', ServeApp.INSTANCE],
     ['/styles.css', ServeAsset.INSTANCE],
     ['/sw.js', ServeAsset.INSTANCE],
@@ -75,6 +80,24 @@ function processRequest(req: http.IncomingMessage, res: http.ServerResponse): vo
     return;
   }
 
+  if (process.env.BASIC_AUTH) {
+    let bad = false;
+    if (!req.headers.authorization) {
+      bad = true;
+    } else {
+      const parts = req.headers.authorization.split(' ', 2);
+      const value = Buffer.from(parts[1], 'base64').toString('ascii');
+      bad = value !== process.env.BASIC_AUTH;
+    }
+    if (bad) {
+      res.writeHead(401, {
+        'WWW-Authenticate': 'Basic realm="BIPTA PCTF"',
+      });
+      res.end();
+      return;
+    }
+  }
+
   const url = new URL(req.url, `http://${req.headers.host}`);
   const ctx = {url, route, serverId, gameLoader: GameLoader.getInstance()};
   const handler: IHandler | undefined = handlers.get(url.pathname);
@@ -132,8 +155,17 @@ Database.getInstance().initialize()
     console.log('Starting server on port ' + (process.env.PORT || 8080));
     console.log('version 0.X');
 
+    if (process.env.BODY_LOG) {
+      console.log('Logging bodies to ' + process.env.BODY_LOG);
+      BodyLog.initialize(process.env.BODY_LOG);
+    }
+
     server.listen(process.env.PORT || 8080);
 
+    if (process.env.BASIC_AUTH) {
+      console.log('Expecting basic auth: ' + process.env.BASIC_AUTH);
+    }
+
     console.log();
     console.log(
       'The secret serverId for this server is \x1b[1m' +
diff --git a/src/styles/challenge.less b/src/styles/challenge.less
new file mode 100644
index 000000000..bbbab3a46
--- /dev/null
+++ b/src/styles/challenge.less
@@ -0,0 +1,33 @@
+.start-challenge {
+    max-width: 30em;
+    margin: 0 auto;
+    padding: 3em 0;
+}
+
+.start-challenge > .start-screen-link {
+    margin: 0 auto;
+}
+
+.challenge-status {
+    margin: 5px 0;
+    text-align: center;
+    font-family: 'Prototype';
+}
+
+.challenge-status:after {
+    content: 'üèÅ';
+    font-size: 13px;
+    vertical-align: text-top;
+    margin-left: 4px;
+    margin-right: -4px;
+}
+
+.challenge-game-end {
+    max-width: fit-content;
+    margin: 0 auto;
+}
+
+.challenge-flag {
+    max-width: 370px;
+    word-wrap: break-word;
+}
diff --git a/src/styles/common.less b/src/styles/common.less
index 72239de4e..993e049ad 100644
--- a/src/styles/common.less
+++ b/src/styles/common.less
@@ -236,3 +236,4 @@ h2 {
 @import "./debug_ui.less";
 @import "./moon.less";
 @import "./pathfinders.less";
+@import "./challenge.less";
\ No newline at end of file
