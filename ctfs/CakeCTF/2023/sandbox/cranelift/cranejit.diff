diff --git a/src/bin/toy.rs b/src/bin/toy.rs
index a12bace..fff0965 100644
--- a/src/bin/toy.rs
+++ b/src/bin/toy.rs
@@ -1,37 +1,18 @@
+use std::fs;
+use std::env;
 use core::mem;
 use cranelift_jit_demo::jit;
 
-fn main() -> Result<(), String> {
+fn main() {
     // Create the JIT instance, which manages all generated functions and data.
     let mut jit = jit::JIT::default();
-    println!("the answer is: {}", run_foo(&mut jit)?);
-    println!(
-        "recursive_fib(10) = {}",
-        run_recursive_fib_code(&mut jit, 10)?
-    );
-    println!(
-        "iterative_fib(10) = {}",
-        run_iterative_fib_code(&mut jit, 10)?
-    );
-    run_hello(&mut jit)?;
-    Ok(())
-}
-
-fn run_foo(jit: &mut jit::JIT) -> Result<isize, String> {
-    unsafe { run_code(jit, FOO_CODE, (1, 0)) }
-}
-
-fn run_recursive_fib_code(jit: &mut jit::JIT, input: isize) -> Result<isize, String> {
-    unsafe { run_code(jit, RECURSIVE_FIB_CODE, input) }
-}
-
-fn run_iterative_fib_code(jit: &mut jit::JIT, input: isize) -> Result<isize, String> {
-    unsafe { run_code(jit, ITERATIVE_FIB_CODE, input) }
-}
-
-fn run_hello(jit: &mut jit::JIT) -> Result<isize, String> {
-    jit.create_data("hello_string", "hello world!\0".as_bytes().to_vec())?;
-    unsafe { run_code(jit, HELLO_CODE, ()) }
+    let args: Vec<String> = env::args().collect();
+    if args.len() < 2 {
+        println!("Usage: toy <filename>");
+        return;
+    }
+    let code = fs::read_to_string(&args[1]).unwrap();
+    let _r: bool = unsafe { run_code(&mut jit, &code, ()).unwrap() };
 }
 
 /// Executes the given code using the cranelift JIT compiler.
@@ -52,66 +33,3 @@ unsafe fn run_code<I, O>(jit: &mut jit::JIT, code: &str, input: I) -> Result<O,
     // And now we can call it!
     Ok(code_fn(input))
 }
-
-// A small test function.
-//
-// The `(c)` declares a return variable; the function returns whatever value
-// it was assigned when the function exits. Note that there are multiple
-// assignments, so the input is not in SSA form, but that's ok because
-// Cranelift handles all the details of translating into SSA form itself.
-const FOO_CODE: &str = r#"
-    fn foo(a, b) -> (c) {
-        c = if a {
-            if b {
-                30
-            } else {
-                40
-            }
-        } else {
-            50
-        }
-        c = c + 2
-    }
-"#;
-
-/// Another example: Recursive fibonacci.
-const RECURSIVE_FIB_CODE: &str = r#"
-    fn recursive_fib(n) -> (r) {
-        r = if n == 0 {
-                    0
-            } else {
-                if n == 1 {
-                    1
-                } else {
-                    recursive_fib(n - 1) + recursive_fib(n - 2)
-                }
-            }
-    }
-"#;
-
-/// Another example: Iterative fibonacci.
-const ITERATIVE_FIB_CODE: &str = r#"
-    fn iterative_fib(n) -> (r) {
-        if n == 0 {
-            r = 0
-        } else {
-            n = n - 1
-            a = 0
-            r = 1
-            while n != 0 {
-                t = r
-                r = r + a
-                a = t
-                n = n - 1
-            }
-        }
-    }
-"#;
-
-/// Let's say hello, by calling into libc. The puts function is resolved by
-/// dlsym to the libc function, and the string &hello_string is defined below.
-const HELLO_CODE: &str = r#"
-fn hello() -> (r) {
-    puts(&hello_string)
-}
-"#;
